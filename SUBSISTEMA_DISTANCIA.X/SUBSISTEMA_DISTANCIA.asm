;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                    FEVEREIRO DE 2016                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		COUNT_SYNC
		COUNT_48
		COUNT_8BITS
		BYTE
		ADDRESS
		DADO_PARA_ENVIAR
		BITS
		CONT_START_SYNC_MASTER
		DELAY_SYNC
		DISTANCIA
		CONT_HIGH
		CONT_LOW
		MONITORA_BITS
		
		LENDO_SENSOR ; REFERENTE A LEITURA DO SENSOR PARA SABER SE LEU TUDO CERTO
		CONT_2
		CONT_1
		BARRAMENTO ; REGISTRADOR DE DADOS SOBRE O BARRAMENTO
		DISTANCIA_AUX
		
		CONTADOR_START_SYNC
		PROPRIETARIO
		CONTADOR_START_BIT
		CONTADOR_BYTES
		CONTADOR_BITS
		ESTAGIO
		ENDERECO_ENVIAR
		
		;NOVAS VARIÁVEIS

	ENDC			;FIM DO BLOCO DE MEMÓRIA
		
	CBLOCK	0x40
		BYTE_0
		ENDERECO
		DADO
	ENDC
	
	CBLOCK	0x50
		LIMITE_COLISAO
		TAXA_AMOSTRAGEM
	;NOVAS VARIÁVEIS

	ENDC
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA
#DEFINE	FLAG_COL_START_BIT  BARRAMENTO, 3   ; BIT REFERENTE A COLISAO NO START_BIT
#DEFINE	FLAG_COL_ENVIAR_BIT BARRAMENTO, 4   ; BIT REFERENTE A COLISAO AO ENVIAR BIT
#DEFINE	FLAG_COLISAO	    BARRAMENTO, 1   ; BIT REFERENTE A COLISAO
#DEFINE	FLAG_BYTE_0	    ESTAGIO, 1	    ; FLAG REFERENTE AO ESTAGIO DO BYTE_0
#DEFINE	FLAG_ENDERECO	    ESTAGIO, 2	    ; FLAG REFERENTE AO ESTAGIO DO ENDERECO
#DEFINE	FLAG_DADO	    ESTAGIO, 3	    ; FLAG REFERENTE AO ESTAGIO DO DADO
#DEFINE DISTANCIA_MINIMA    .8

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;A PARTIR DO ENDEREÇO ZERO DA EEPROM, DADOS EM ORDEM ALEATÓRIA
	ORG 0x2100
	DE	0X03,0X01,0X0F	; VALORES FIXOS DO SUBSISTEMA DE COLISÃO, BYTE_0, ENDEREÇO E DADO

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP
	BCF	INTCON, T0IF
	;BSF	GPIO, GP0

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES
    BTFSC	FLAG_COLISAO
	GOTO	TRATAR_COLISAO
	GOTO	INICIO_START_SYNC

TRATAR_COLISAO
	BTFSS	    FLAG_COL_START_BIT
	    GOTO    LER_BITS
	    GOTO    INIC_CONT_START_SYNC
	    
INIC_CONT_START_SYNC
	INCF	CONTADOR_START_SYNC
	MOVLW	.155
	MOVWF	TMR0
	GOTO	START_SYNC
; INTERRUPÇÕES
INICIO_START_SYNC
	MOVLW	.8
	MOVWF	CONTADOR_BITS		; TEM QUE TER ISSO PARA QUE O CONTADOR DE BITS COMECE COM SE NAO ELE FICA PRESO NO LER BITS
	MOVLW	.53;.55		    ; SERÁ VISTO QUANTAS VEZES O TIMER0 ESTOURARÁ
	MOVWF	TMR0
START_SYNC
	BTFSC	GPIO, GP2
	GOTO	VERIFICA_SLAVER	    ; QUANDO O GP2 DESCER, É TESTADO SE É SLAVE OU MASTER 
	BTFSC	INTCON, T0IF	    ; VERIFICA SE HOUVE ESTOURO DO TIMER 0
	GOTO	INCREMENTA_LIMPA    ; INCREMENTA O CONTADOR DO START_SYNC
	GOTO	START_SYNC	    ; SE NÃO, REINICIA
	
INCREMENTA_LIMPA
	BTFSC	CONTADOR_START_SYNC, 2	; VERIFICA E PASSOU DE 3 O INCREMTETO, SE SIM, SAI
	    GOTO	SAI_INT
	INCF	CONTADOR_START_SYNC
	BCF	INTCON, T0IF
	GOTO	INICIO_START_SYNC
	
VERIFICA_SLAVER
	MOVLW	0x40			; ENDEREÇO APONTADO CASO SEJA SLAVE NA MEMORIA
	MOVWF	FSR			; PONTEIRO APONTANDO NO ENDEREÇO 0x30 NA MEMÓRIA RAM
	MOVLW	.3			; CONTADOR DE BYTES, REFERENTE AO BYTE 0, MELHORAR ESSE DADO
	MOVWF	CONTADOR_BYTES
	DECFSZ	CONTADOR_START_SYNC	; DECREMENTA O CONTADOR E VERIFICA SE ELE É ZERO,
	GOTO	VERIFICA_MASTER		; SE FOR ZERO, O TIMER ZERO ESTOUROU 1 VEZ SÓ, ENTÃO É SLAVE
	BSF	PROPRIETARIO, 0		; BIT 0 REFERENTE AO SLAVER
	;BSF	GPIO,GP0	
	GOTO	START_BIT_INICIO	; INICIA A VERIFICAÇÃO DO START BIT
	
VERIFICA_MASTER				; VERIFICA SE É MASTER
	DECFSZ	CONTADOR_START_SYNC
	GOTO	SAI_INT			; DEU PROBLEMA, NÃO É UM START_SUMC
	BSF	PROPRIETARIO, 1		; BIT 1 REFERENTE AO MASTER
	;BSF	GPIO,GP0
	;MOVLW	0x40
	;MOVWF	FSR
	;MOVLW	.4
	;MOVWF	CONTADOR_BYTES
	GOTO	START_BIT_INICIO
;==================================================
START_BIT_INICIO

	;BSF	GPIO, GP1		; CASO O BARRAMENTO NÃO SUBA, ELE FOI TRATADO ANTERIORMENTE NO START_SYNC. SE O BARRAMENTO FICAR EM LOW, TODO O BARRAMENTO ESTARA COM PROBLEMAS
	BTFSS	GPIO, GP2		; ESPERA O BARRAMENTO SUBIR
	GOTO	START_BIT_INICIO	
START_BIT_CONFIGURA			; CONFIGURA O REINICIO DA CONTAGEM DO START BIT PARA O CONTADOR QUANDO O TIMER ZERO ESTOURAR
	BCF	INTCON, T0IF
	MOVLW	.145			; O TMR0 ESTOURARÁ A CADA 130 US
	MOVWF	TMR0
START_BIT
	BTFSS	GPIO, GP2
	GOTO	VERIFICA_START_BIT
	BTFSC	INTCON, T0IF		; VERIFICA SE O TIMER ZERO ESTOUROU
	GOTO	INCREMENTA_START_BIT	; SE SIM, INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT		; SE NÃO, CONTINUA A CONTAGEM
INCREMENTA_START_BIT
	 ;BSF	GPIO, GP4
	BTFSC	CONTADOR_START_BIT, 1	; TESTA SE HOUVE MAIS DE UM ESTOURO DO TIMER0, SE SIM, SAI DA INTERRUÇÃO
	    GOTO	SAI_INT
	INCF	CONTADOR_START_BIT	; INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT_CONFIGURA 
VERIFICA_START_BIT

	DECFSZ	CONTADOR_START_BIT	; VERIFICA SE HOUVE APENAS UM ESTOURO NO TIMER 0 NA SUBIDA DO START BIT
	GOTO	SAI_INT			; SE HOUVE MAIS DE 1 OU MENOS, NÃO CARACTERIZA UM START BIT E SAI DA INTERRUPÇÃO
	GOTO	START_BIT_LOW_INICIO		; SE HOUVE APENAS 1 ESTOURO, CONTINUA A VERIFICAÇÃO PARA O TEMPO EM LOW

	
START_BIT_LOW_INICIO			; CODIGO PARECIDO COM A VERIFICAÇÃO DO TEMPO EM ALTA DO START BIT
	; BSF	GPIO, GP4
	BCF	INTCON, T0IF		; MAS AGORA É TESTADO COM O TEMPO EM LOW
	MOVLW	.145
	MOVWF	TMR0
START_BIT_LOW
	BTFSC	GPIO, GP2
	GOTO	SAI_INT			
	BTFSC	INTCON, T0IF
	GOTO	ESPERA_SUBIDA_START_BIT
	GOTO	START_BIT_LOW
	
ESPERA_SUBIDA_START_BIT
	BCF	INTCON, T0IF
	MOVLW	.225			; O TMR0 ESTOURARÁ A CADA 130 US
	MOVWF	TMR0
ESPERA_SUBIDA_ST	
	BTFSC	GPIO, GP2
	GOTO	LER_BITS
	BTFSC	INTCON, T0IF
	GOTO	SAI_INT			; SE O BARRAMENTO NÃO SUBIR NO INTERVALO DE TEMPO DADO, NÃO CARACTERIZA UM START BIT
	GOTO	ESPERA_SUBIDA_ST
	
;====================================
	
LER_BITS
	;BSF	GPIO, GP2 ; APAGAR
	BCF	INTCON, T0IF		; LIMPA A FLAG DE ESTOURO DO TIMER ZERO
	MOVLW	.232;.234			; O TIMER ZERO ESTOURARÁ A CADA 30 US (BASE), QUANDO HOUVER O ESTOURO, É VERIFICADO
	MOVWF	TMR0			; O ESTADO DO BARRAMENTO, SE O BARRAMENTO ESTIVER EM ALTA, SIGNIFICA QUE O BARRAMENTO AINDA NÃO BAIXOU, OU SEJA, CARACTERIZA O BIT 1 (40(H)) > 30 US
	MOVLW   .248
	MOVWF	MONITORA_BITS
LER_BITS_CONTINUA			; CASO O BARRAMENTO ESTEJA EM LOW, SIGNIFICA QUE O BARRAMENTO JÁ FOI PARA LOW, OU SEJA, O BIT LIDO É O ZERO (20(H) + 10(L)) = 30 US
	;BTFSS	GPIO, GP2
	;GOTO	VERIFICA_1_0
	;BTFSC	INTCON, T0IF		; VERIFICA SE HOUVE ESTOURO DO TIMER ZERO
	;GOTO	VERIFICA_1_0		; VERIFICA SE O BIT LIDO É ZERO OU UM
	INCFSZ	MONITORA_BITS		; SE ESTOURAR, É SINAL QUE HOUVE ALGUM ERRO, E O PROGRAMA SAI
	    GOTO    $+2
	    GOTO    SAI_INT
	
	BTFSC	GPIO, GP2
	    GOTO	LER_BITS_CONTINUA
	    GOTO	VERIFICA_1_0
	
	
	
;INCREMENTA_CONTADOR_BITS
;	INCF	CONTADOR_TEMPO_BITS
;	GOTO	LER_BITS
VERIFICA_1_0		    ; VERIFICA SE É O BIT 1 OU 0
	BTFSS	INTCON, T0IF    ;GPIO, GP2
	GOTO	BIT_0
	GOTO	BIT_1

BIT_0
	BCF	STATUS, C
	RLF	INDF
	
	
	
	DECFSZ	CONTADOR_BITS		; DECREMENTA O CONTADOR DE BITS 
	GOTO	ESPERA_BIT_0_MUDAR	; SE NÃO FOR ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	INCF	FSR			; SE ACABOU, INCREMENTA O PONTEIRO PARA O PROXIMO ENDEREÇO DE MEMÓRIA	    
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES		; DECREMENTA O CONTADOR DE BYTES QUE TEM QUE SER LIDO
	GOTO	ESPERA_BIT_0_MUDAR	; CASO NÃO SEJA ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	GOTO	CONCLUIDA_LEITURA	; CASO SEJA ZERO, A LEITURA DOS DADOS DO BARRAMENTO ESTÁ FINALIZADO.
	
ESPERA_BIT_0_MUDAR		
	BTFSS	GPIO, GP2
	GOTO	ESPERA_BIT_0_MUDAR
	GOTO	LER_BITS

BIT_1
	BSF	STATUS, C
	RLF	INDF
	
	
	
	
	DECFSZ	CONTADOR_BITS
	GOTO	ESPERA_BIT_1_MUDAR
	INCF	FSR
	;BSF	GPIO, GP4
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES
	GOTO	ESPERA_BIT_1_MUDAR
	GOTO	CONCLUIDA_LEITURA
	
ESPERA_BIT_1_MUDAR
	;BTFSC	GPIO, GP2
	;GOTO	ESPERA_BIT_1_MUDAR

	BTFSS	GPIO, GP2
	GOTO	$-1
	GOTO	LER_BITS
	
	
CONCLUIDA_LEITURA
	;BSF	GPIO, GP1
	;BTFSS	BARRAMENTO, 6
	;    GOTO    PASSA_BYTE_0
	BSF	BARRAMENTO, 5		; LEITURA DO BARRAMENTO OCORREU COM SUCESSO
	
	DECFSZ	DADO
	    GOTO	SAI_INT
	    BSF		BARRAMENTO, 7	; É PRA ENVIAR A DISTANCIA
	

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	CLRF	CONTADOR_START_SYNC
	CLRF	CONTADOR_START_BIT
	BCF	INTCON, INTF		; LIMPA QUE HOUVE INTERRUPÇÃO DO GP2
	BCF	BARRAMENTO, 1
	BCF	FLAG_COLISAO
	BCF	FLAG_COL_START_BIT
	
	
	BCF	BARRAMENTO, 6		; LIMPA A FLAG
	BCF	LENDO_SENSOR, 0		; LIMPA O BIT PARA DIZER QUE A LEITURA DO SENSOR FOI INTERROMPIDA
	;BCF	BARRAMENTO, 4

	;BCF	BARRAMENTO, 2
	;CLRF	BARRAMENTO
	;BCF	GPIO, GP4
	
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.

CONTA_TEMPO		    ; CONTA QUANTAS VEZES O TM0 ESTOUROU, EQUIVALENTE A 1CM CADA VEZ QUE ESTOURAR

	MOVLW	.203;.203;.232 ; 226
	MOVWF	TMR0
	;CLRF	ACCbHI
	CLRF	DISTANCIA_AUX	; REGISTRADOR AUXILIA PARA A LEITURA DA DISTANCIA
	;CORPO DA ROTINA
TMR0_ESTOURO
	BTFSS	GPIO, GP4    ;ECHO
	GOTO	TERMINOU
	BTFSS	INTCON, T0IF
	GOTO	TMR0_ESTOURO
	BCF	INTCON, T0IF
	
	;INCF	CONT_HIGH
	;INCF	ACCbHI
	INCF	DISTANCIA_AUX	; QUARDA O VALOR DE QUANTAS VEZES HOUVE ESTOURO NA DISTANCIA ( CM )
	BTFSC	DISTANCIA_AUX, 7    ; TESTA SE O VALOR É MAIOR DO QUE 127, SE SIM, SAIA PARA N FICAR PRESO NO LOOP
	    GOTO    TERMINOU
	MOVLW	.203;.203 ;.232
	MOVWF	TMR0
	GOTO	TMR0_ESTOURO
	
TERMINOU
	BCF	STATUS, C
	; VERIFICAR SE A LEITURA OCORREU SEM INTERRUPÇÃO
	; TESTO SE O BIT QUE É SETADO NO INICIO AINDA ESTÁ SETADO OU A INTERRUPÇÃO NÃO LIMPOU
	BTFSS	LENDO_SENSOR, 0	    ; TESTA SE FOI LIMPADO NA INTERRUPÇÃO
	    RETURN		    ; SE SIM, NÃO PASSAR ESSE RESULTADO E O RESULTADO FICA O ANTERIOR
	    BCF	    LENDO_SENSOR, 0 ; SE NÃO, MOVER O RESUTALDO DO AUXILIAR PARA A DISTANCIA
	    MOVF    DISTANCIA_AUX, W
	    MOVWF   DISTANCIA
	MOVF	TMR0, W
	BCF	INTCON, INTF	    ; LIMPA A FLAG DE INTERRUPÇÃO
	; VERIFICAR SE É MAIOR QUE 127 CM
	MOVLW	.127		    ; VALOR MAXIMO DE LEITURA
	SUBWF	DISTANCIA, 0
	BTFSS	STATUS, C	    ; TESTA SE O VALOR É MAIOR QUE 127
	    GOTO    $+3
	    MOVLW   .127
	    MOVWF   DISTANCIA
	    
	BCF	STATUS, C
	; VERIFICAR SE O VALOR LIDO É MENOR QUE 4 CM E SETAR O BIT 7 DA DISTANCIA
	MOVLW	DISTANCIA_MINIMA    ;.8		    ; VALOR QUE ACUSA A COLISAO
	SUBWF	DISTANCIA, 0	    ;  SE A DISTANCIA FOR MENOR QUE 10, O CARRY É SETADO
	BTFSS	STATUS, C
	    GOTO	SETA_COLISAO ;
	    GOTO	TIRA_COLISAO
SETA_COLISAO
	BSF	    DISTANCIA, 7    ; DIZ QUE HOUVE UMA COLISÃO
	GOTO 	    SAIR_CONTA_TEMPO
TIRA_COLISAO
	BCF	    DISTANCIA, 7
	GOTO 	    SAIR_CONTA_TEMPO
	
SAIR_CONTA_TEMPO
	MOVLW	B'00111100'	    ; RECONFIGURA O TIMER1
	MOVWF	TMR1H
	MOVLW	B'10101111'
	MOVWF	TMR1L
	
	RETURN
HOUVE_LEITURA
	; SEMPRE QUE HOUVER UMA LEITURA, VERIFICAR SE O BIT 7 DO DADO NÃO ESTA SETADO, POIS EQUIVALE
	; AO BIT CORRESPONDENTE A COLISÃO
	BCF	BARRAMENTO, 5		; LIMPA O SINALIZADOR DE LEITURA DO BARRAMENTO
    BTFSS	BARRAMENTO, 7		; VERIFICA SE HOUVE UMA REQUISIÇÃO DOS DADOS
	GOTO    MAIN
	
SINALIZAR_COLISAO			; CASO HOUVER COLISÃO DO VEICULO, ENVIAR DIRETAMENTE
	
	BCF	INTCON, GIE
	BCF	STATUS, C
	;BCF	INTCON,	PEIE
	;BCF	INTCON,	INTE
	;CLRF	INTCON
	;DEFINE OPÇÕES DE INTERRUPÇÕES
	; DESABILITA AS INTERRUPÇÕES		; DESABILITA AS INTERRUPÇÕES
	;MOVF	ENDERECO_ENVIAR, W  ;	MOVO O ENDEREÇO DO SUBSISTEMA QUE ENVIARÁ DOS DADOS
	;MOVWF	ENDERECO	    ;	PARA O ENDEREÇO QUE SERÁ LIDO
	; PASSO OS DADOS QUE SERA ENVIADO
	;MOVF	DISTANCIA, W		; APÓS VERIFICAR O BARRAMENDO, O DADO NÃO SERÁ MAIS ALTERADO
	;MOVWF	DADO			; MOVE O A DISTANCIA LIDA PARA O DADO A SER ENVIADO
	;BCF	DISTANCIA, 7		; LIMPA O BIT CORRESPONDENTE A COLISÃO
	BSF	BARRAMENTO, 0		; SINALIZA QUE O DADO SERÁ ENVIADO, TEM QUE SER LIMPO PARA N PRECISAR REENVIAR
	MOVLW	DISTANCIA_MINIMA    ;.8		    ; VALOR QUE ACUSA A COLISAO
	SUBWF	DISTANCIA, 0	    ;  SE A DISTANCIA FOR MENOR QUE 10, O CARRY É SETADO
	BTFSS	STATUS, C
	    BSF	    DISTANCIA, 7
	CALL    VERIFICA_BARRAMENTO	; VERIFICA SE O BARRAMENTO ESTA LIVRE
	GOTO    ENVIA_DADOS	
REENVIAR_DADO
	CALL    VERIFICA_BARRAMENTO	; VERIFICA SE O BARRAMENTO ESTA LIVRE
	;MOVF	DISTANCIA, W		; APÓS VERIFICAR O BARRAMENDO, O DADO NÃO SERÁ MAIS ALTERADO
	;MOVWF	DADO
	GOTO    ENVIA_DADOS		

LE_EEPROM
;LER DADO DA EEPROM, CUJO ENDEREÇO É INDICADO EM W
;DADO LIDO RETORNA EM W
	ANDLW	.127		;LIMITA ENDEREÇO MAX. 127
	BANK1				;ACESSO VIA BANK 1
	MOVWF	EEADR		;INDICA O END. DE LEITURA
	BSF		EECON1,RD	;INICIA O PROCESSO DE LEITURA
	MOVF	EEDATA,W	;COLOCA DADO LIDO EM W
	BANK0				;POSICIONA PARA BANK 0
	RETURN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00011100' ;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		;COMO SAÍDAS
	CLRF	ANSEL 		;DEFINE PORTAS COMO Digital I/O
	MOVLW	B'10001000'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	;MOVLW	B'11010000'
	;MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	CALL	0x3FF
	;MOVLW	.48
	MOVWF	OSCCAL
	BANK0				;RETORNA PARA O BANCO
	MOVLW	B'00010001'
	MOVWF	T1CON			; HABILITANDO O TIMER 1
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	CLRF	GPIO
	BSF	GPIO, GP1
	MOVLW	0X0F
	MOVLW	DISTANCIA
	MOVLW	.0
	MOVWF	TMR0
	BCF	INTCON, INTF 
	

	

	MOVLW	.0
	CALL	LE_EEPROM
	MOVWF	BYTE_0		    ; BYTE_0 QUE SERÁ ENVIADO NO BARRAMENTO
	MOVLW	.1
	CALL	LE_EEPROM
	MOVWF	ENDERECO_ENVIAR	    ; ENDEREÇO QUE SERÁ ENVIADO NO BARRAMENTO
	MOVLW	.2
	CALL	LE_EEPROM
	MOVWF	DADO		    ; DADO QUE SERÁ ENVIADO NO BARRAMENTO
	MOVLW	B'00000001'
	MOVWF	DADO_PARA_ENVIAR
	
	;BSF	GPIO, GP1
	;MOVWF	SBYTE_0
	
	;MOVLW	B'00011110'
	;MOVWF	DADO_SLAVER
	
	
	;BCF	GPIO, GP0   ;APENAS PARA SIMULAÇÃO, APAGAR AQUI <----
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
INICIALIZANDO_TMR1	    ; TIMER1 CONTARÁ 100 MS PARA QUE SEJA FEITA UMA LEITURA DO SONAR
	MOVLW	B'00111100'
	MOVWF	TMR1H
	MOVLW	B'10101111'
	MOVWF	TMR1L
	
	MOVLW	B'01010000'		; DESABILITA A INTERRUPÇÃO APOS ENVIAR OS DADOS
	MOVWF	INTCON			; DEFINE OPÇÕES DE INTERRUPÇÕES
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; GP0 -> TRIGGER
; GP2 -> LER O BARRAMENTO
; GP1 -> ENVIA NO BARRAMENTO
; GP4 -> ECHO
CALL	DELAY100MS
	
MAIN
	; MOVLW	.1
	 ;MOVWF	BYTE_0
	 BCF	INTCON, GIE
	 CALL	DELAY10MS
	 CALL	DELAY10MS
	 CALL	DELAY10MS
	; BSF	INTCON,	PEIE
	; BSF	INTCON,	INTE
	
	;BTFSC	BARRAMENTO, 5		; TESTA O SINALIZADOR DE LEITURA DO BARRAMENTO, LIMPO NO HOUVE_LEITURA
	;    GOTO    HOUVE_LEITURA	; HOUVE LEITURA, ENTÃO DEVERÁ CHECAR O DADO
	;BTFSS	GPIO, GP1		; ESPERA O BOTÃO GP1 SER ACIONADO, MAS ISSO É SO PRA TESTES
	;BTFSC	DISTANCIA, 7		; VERIFICA SE HOUVE COLISAO
	;    GOTO    SINALIZAR_COLISAO	; SE HOUVE, MANDAR IMEDIATAMENTE PARA A O BARRAMENTO
	;GOTO	MAIN
					; A CADA 100 MS FAZER UMA NOVA LEITURA, UTILIZAR O TIMER 1
	;BTFSC	PIR1, TMR1IF		; VERIFICA SE HOUVE ESTOURO DO TIMER1 DE 100 MS
	GOTO	SONAR			; CHAMA O SONAR PARA RECEBER A MEDIDA
FIM_SONAR
	;CALL	DELAY100MS		; DELAY QUE O TEMPO QUE O SENSOR PODERAR FAZER UMA NOVA LEITURA
	;CALL	DELAY48
	BCF	STATUS, C		; LIMPA A FLAG
	; DESABILITAR INTERRUPÇÕES AO ENVIAR DADOS NO BARRAMENTO [TO DO]
	;CLRF	INTCON			; DESABILITA A INTERRUPÇÃO
	;GOTO	ENVIA_DADOS		; ENVIA OS DADOS LIDOS DO SONAR AO BARRAMENTO COM O PROTOCOLO ONE WIRE
	;CALL	VERIFICA_BARRAMENTO
	;GOTO	ENVIA_DADOS
	GOTO	SINALIZAR_COLISAO
	GOTO	MAIN
FIM_ENVIA_DADOS
;	BANK1
;	BSF	TRISIO, 2
;	BANK0
	BTFSC	BARRAMENTO, 0	; TESTA SE O DADO REQUERIDO FOI ENVIADO
	    GOTO	REENVIAR_DADO	; SE NÃO ESTIVER EM LOW, O DADO SERÁ REENVIADO
	BCF	DISTANCIA, 7		; LIMPA O BIT CORRESPONDENTE A COLISÃO

	;CALL	DELAY100MS
	;INCF	DADOS
	GOTO	MAIN
	;GOTO	$
	
;###########################################################
SONAR
	;BTFSS	GPIO, GP4
	;GOTO	$-1
	; SETA UM BIT PARA AVISAR QUE ESTÁ LENDO O SENSOR
	BSF	LENDO_SENSOR, 0	    ; SINALIZA QUE ESTÁ LENDO O SENSOR
	BCF	PIR1, TMR1IF	; LIMPA A FLAG DE ESTOURO DO TIMER1
	BSF	GPIO, GP0
	
	;====================== DELAY DE 10 uS
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	;=======================
	
	BCF	GPIO,	GP0
	
	;CALL	DELAY8
	;GOTO	SONAR

; ESPERA O RETORNO DO ECHO
ESPERA_ECHO
	;BTFSS	LENDO_SENSOR, 0
	;	GOTO	MAIN
	BTFSS	GPIO, GP4	;   ESPERA O TEMPO SONAR RESPONDER COM O ECHO
	    GOTO	ESPERA_ECHO
	    CALL	CONTA_TEMPO	;   CONTA O TEMPO QUE FICOU EM ALTA
	
	GOTO	FIM_SONAR



;######################################################################################################

;######################################################################################################
;=============================================================
VERIFICA_BARRAMENTO		; VERIFICO SE O BARRAMENTO ESTÁ LIVRE POR 200 US
	;MOVLW	B'11010000'	; HABILITA A INTERRUPÇÃO
	;MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	BSF	INTCON, GIE
	BCF	INTCON, T0IF
	BCF	BARRAMENTO, 5	; LIMPA O SINALIZADOR DE LEITURA DO BARRAMENTO
	; TESTA SE O VALOR LIDO É REFERENTE AO STOP DA COLISAO
	;   SE FOR, TRATAR ESSE DADO
	MOVLW	.70;.20
	MOVWF	TMR0
	BTFSS	GPIO, GP2		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	
VERIFICA_BARRAMENTO_0

	BTFSS	GPIO, GP2		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	BTFSS	INTCON, T0IF
	GOTO	VERIFICA_BARRAMENTO_0
	BTFSC	BARRAMENTO, 5	; HOUVE UMA LEITURA NO BARRAMENTO?
	 GOTO	VERIFICA_BARRAMENTO
	;BSF	BARRAMENTO, 0	   ; SINALIZO BARRAMENTO LIVRE. (É NECESSÁRIO?)
	RETURN
;=============================================================
ENVIA_DADOS
	    ;BCF		GPIO, GP1
	      BCF	INTCON, GIE		; DESABILITA AS INTERRUPÇÕES
	      ;BCF	INTCON,	PEIE
	      ;BCF	INTCON,	INTE
	;===========
	    MOVF	ENDERECO_ENVIAR, W
	    MOVWF	ENDERECO
	    
	    MOVLW	0x3F			; ENDEREÇO APONTADO PARA O ENREREÇO RESERVADO PARA LEITURA DOS DADOS 
						; PARA SER INCREMENTADO POR IGUAL NO ENVIO DOS BYTES
	    MOVWF	FSR			; PONTEIRO
	    MOVLW	.3
	    MOVWF	CONTADOR_BYTES
	    CLRF	ESTAGIO			; LIMPA O ESTAGIO PARA COMEÇAR A ENVIAR OS 3 BYTES
	    MOVF	DISTANCIA, W		; APÓS VERIFICAR O BARRAMENDO, O DADO NÃO SERÁ MAIS ALTERADO
	    MOVWF	DADO			; MOVE O A DISTANCIA LIDA PARA O DADO A SER ENVIADO
	    CALL	START_SYNC_SLAVE	; PASSA 250 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	    GOTO	START_BIT_ENVIA
FIM_START_BIT
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
		;BSF	CONTADOR_BITS, 3    ; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
		MOVLW	.8
		MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 1	    ; SINALIZA QUE É O ENVIO DO BYTE 0
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_BYTE_0
		;NOP
		NOP
		NOP
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
		MOVLW	.8
		MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 2	    ; SINALIZA QUE É O ENVIO DO ENDEREÇO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_ENDERECO
		;NOP
		NOP
		NOP
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
		MOVLW	.8
		MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 3	    ; SINALIZA QUE É O ENVIO DO DADO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_DADO
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		CALL	DELAY_US
		BSF	GPIO, GP1	    ; COLOCA O BARRAMENTO LIVRE, DEIXANDO ELE EM ALTA
		
		BCF	BARRAMENTO, 0	    ; SINALIZA QUE HOUVE O ENVIO DO DADO
		BCF	BARRAMENTO, 7	    ; SINALIZA QUE O DADO PEDIDO FOI ENVIADO
		GOTO	FIM_ENVIA_DADOS
	
START_BIT_ENVIA
	;DELAY DE 50 US EM ALTA
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	BTFSS	GPIO, GP2
	    GOTO    COLISAO_START_BIT	; SE HOUVER COLISÃO, TRATAR OS DADOS REFENTE A ELA
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	
	; DELAY DE 150 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	BCF	GPIO, GP1
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	
	GOTO	FIM_START_BIT	    ; ACABOU O START BIT, AGORA VAI COMEÇAR A ENVIAR OS DADOS
	

ENVIA_BYTE 
    BTFSS   INDF, 7
	GOTO	ENVIA_0
	GOTO	ENVIA_1

ENVIA_0
	BSF	GPIO, 5
	CALL	DELAY_US
	NOP
	RLF	INDF	    
	
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    GPIO, 5		; FICA EM BAIXA O BARRAMENTO
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0

ENVIA_1
	BSF	GPIO, 5
	; PASSA 30 US EM ALTA
	CALL	DELAY_US
	NOP
	NOP
	BTFSS	GPIO, GP2		; TESTA SE O BARRAMENTO NÃO ESTÁ COM COLISÃO
	    GOTO    FIM_ENVIA_DADOS	; TRATAR COLISAO BITS
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	RLF	INDF			; ROTACIONA O DADO
	BTFSS	GPIO, GP2		; TESTA SE O BARRAMENTO NÃO ESTÁ COM COLISÃO
	    GOTO    COLISAO_ENVIAR_BITS	; TRATAR COLISAO BITS
	; PASSA MAIS 10 US EM ALTA APOS CHECAR
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    GPIO, 5		; FICA EM BAIXA O BARRAMENTO
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0
TEMPO_EM_BAIXA
	BCF	GPIO, 5
	; PASSA 20 US EM BAIXA
	CALL	DELAY_US
	GOTO	ENVIA_BYTE
COLISAO_START_BIT
	
	BSF	FLAG_COL_START_BIT		; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT
	BSF	FLAG_COLISAO		; SINALIZO QUE HOUVE UMA COLISÃO
	MOVLW	B'11010010'
	MOVWF	INTCON					;   ATIVAR AS INTERRUPÇÕES
	;BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
	
COLISAO_ENVIAR_BITS								
	BCF	INDF,	7				; SETO O BIT DO REGISTRADOR APONTADO PARA 0, POIS HOUVE COLISAO 
	DECFSZ	CONTADOR_BITS, F			; TEM QUE DECREMENTAR O CONTADOR DE BITS, POIS ELE FOI LIDO JÁ E SERA LIDO OUTRA VEZ CASO NÃO DECREMENTE
	    GOTO	$+2
	    GOTO	MAIN
	BSF	FLAG_COL_ENVIAR_BIT			; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT NO REGISTRADOR BARRAMENTO
	BSF	FLAG_COLISAO				; SINALIZO QUE HOUVE UMA COLISÃO
	MOVLW	B'11010000'
	MOVWF	INTCON					;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
	
START_SYNC_SLAVE
	BCF	GPIO, GP1
	; PASSA 250 US EM BAIXA
			;244 cycles
	MOVLW	.81
	MOVWF	DELAY_SYNC
START_SYNC_SLAVE_0
	DECFSZ	DELAY_SYNC, F
	GOTO	START_SYNC_SLAVE_0
	
	;GOTO	$+1
	BSF	GPIO, GP1
	RETURN	
	
	
	
	
	
	
;===============================================================
;################################	DELAYS	    ##################################################
;#####################################################################################################
DELAY100MS
			;99993 cycles
	MOVLW	.30
	movwf	CONT_1
	MOVLW	.79
	movwf	CONT_2
DELAY100MS_0
	DECFSZ	CONT_1
	GOTO	$+2
	DECFSZ	CONT_2
	GOTO	DELAY100MS_0
			;3 cycles
	GOTO	$+1
	NOP
			;4 cycles (including call)
	RETURN
DELAY48			; TOTAL DE 48 CICLOS
			;43 cycles
	MOVLW	.14
	MOVWF	COUNT_48
DELAY48_0
	DECFSZ	COUNT_48, f
	GOTO	DELAY48_0
			;2 cycles
	NOP
			;4 cycles (including call)
	RETURN
;===============================================================
DELAY8
			;4 cycles
	GOTO	$+1
	GOTO	$+1
	RETURN		;4 cycles (including call)	
DELAY_US
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    
    RETURN
  	cblock
	d1
	d2
	endc

DELAY10MS
			;9993 cycles
	movlw	0xCE
	movwf	CONT_1
	movlw	0x08
	movwf	CONT_2
DELAY10MS_0
	decfsz	CONT_1, f
	goto	$+2
	decfsz	CONT_2, f
	goto	DELAY10MS_0

			;3 cycles
	goto	$+1
	nop

			;4 cycles (including call)
	return
;===============================================================	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ESTAS ROTINAS PODEM SER ENCONTRADAS NO DOCUMENTO                *
;http://ww1.microchip.com/downloads/en/AppNotes/00544d.pdf        *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	 

    END
