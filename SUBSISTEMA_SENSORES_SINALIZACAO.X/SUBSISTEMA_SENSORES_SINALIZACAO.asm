;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 16F628A                  *
;*                FEITAS POR LUCAS QUEIROZ                         *
;*                    FEVEREIRO DE 2016                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 16F628A                                    *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p16f628a.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 16F628A

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT & _LVP_OFF  
; _LVP_OFF  =  PARA USAR O RB4

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA


;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		COUNT_SYNC
		
		DELAY_
		BYTE
		
		;DADOS
		BITS
		CONT_START_SYNC_MASTER
		DELAY_SYNC
		
		DADO_SINALIZACAO
		DADO_SENSORES
		
		MONITORA_BITS
		ESTADO_SINALIZACAO
		ENDERECO_SINALIZACAO
		ENDERECO_SENSORES
		VALORES_SENSORES
		CONT_2
		CONT_1
		BARRAMENTO ; REGISTRADOR DE DADOS SOBRE O BARRAMENTO
		
		CONTADOR_START_SYNC
		PROPRIETARIO
		CONTADOR_START_BIT
		CONTADOR_BYTES
		CONTADOR_BITS
		ESTAGIO
		ENDERECO_ENVIAR
		
		ALERTA_ON

		;NOVAS VARIÁVEIS

	ENDC			;FIM DO BLOCO DE MEMÓRIA
		
	CBLOCK	0x40
		BYTE_0
		ENDERECO
		DADO
	ENDC
	
;	CBLOCK	0x50
;		MBYTE_0
;		ANDRESS_MASTER
;		ANDRESS_SUBSISTEMA
;		DADO_MASTER
;	;NOVAS VARIÁVEIS
;
;	ENDC
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA
#DEFINE	FLAG_COL_START_BIT  BARRAMENTO, 3   ; BIT REFERENTE A COLISAO NO START_BIT
#DEFINE	FLAG_COL_ENVIAR_BIT BARRAMENTO, 4   ; BIT REFERENTE A COLISAO AO ENVIAR BIT
#DEFINE	FLAG_COLISAO	    BARRAMENTO, 1   ; BIT REFERENTE A COLISAO
#DEFINE	FLAG_BYTE_0	    ESTAGIO, 1	    ; FLAG REFERENTE AO ESTAGIO DO BYTE_0
#DEFINE	FLAG_ENDERECO	    ESTAGIO, 2	    ; FLAG REFERENTE AO ESTAGIO DO ENDERECO
#DEFINE	FLAG_DADO	    ESTAGIO, 3	    ; FLAG REFERENTE AO ESTAGIO DO DADO

#DEFINE FAROL		    ESTADO_SINALIZACAO, 0
#DEFINE RE		    ESTADO_SINALIZACAO, 1
#DEFINE FREIO		    ESTADO_SINALIZACAO, 2
#DEFINE SETA_ESQUERDA	    ESTADO_SINALIZACAO, 3
#DEFINE SETA_DIREITA	    ESTADO_SINALIZACAO, 4
#DEFINE REQUISICAO	    DADO_SINALIZACAO, 5
	
#DEFINE SENSOR_1	    PORTB, RB4
#DEFINE SENSOR_2	    PORTB, RB5
#DEFINE SENSOR_3	    PORTB, RB6
#DEFINE SENSOR_4	    PORTB, RB7
#DEFINE PWM_FREIO	    .5		    ;	PWM DO FREIO DESACIONADO
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;A PARTIR DO ENDEREÇO ZERO DA EEPROM, DADOS EM ORDEM ALEATÓRIA
	ORG 0x2100
	DE	0X03,0X02,0X05,0X40	; VALORES FIXOS DO SUBSISTEMA
	   ;	BYTE END1 END2 DADO
	   ; END1 = DIREÇÃO
	   ; END2 = SINALIZAÇÃO
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP
	BCF	INTCON, T0IF
;	BANK1
;	BSF	TRISB, 0	; COLOCA O RB0 COMO ENTRADA (ALTA IMPEDANCIA)
;	BANK0
	;BSF	GPIO, GP0
	BTFSC	INTCON, RBIF
	    GOTO    TRATA_SENSORES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES
    BTFSC	FLAG_COLISAO
	GOTO	TRATAR_COLISAO
	GOTO	INICIO_START_SYNC

TRATAR_COLISAO
	BTFSS	    FLAG_COL_START_BIT
	    GOTO    LER_BITS
	    GOTO    INIC_CONT_START_SYNC
	    
INIC_CONT_START_SYNC
	INCF	CONTADOR_START_SYNC
	MOVLW	.155
	MOVWF	TMR0
	GOTO	START_SYNC
; INTERRUPÇÕES
INICIO_START_SYNC
	MOVLW	.8
	MOVWF	CONTADOR_BITS		; TEM QUE TER ISSO PARA QUE O CONTADOR DE BITS COMECE COM SE NAO ELE FICA PRESO NO LER BITS
	MOVLW	.30;.55		    ; SERÁ VISTO QUANTAS VEZES O TIMER0 ESTOURARÁ
	MOVWF	TMR0
START_SYNC
	BTFSC	PORTB, RB0;GP2
	GOTO	VERIFICA_SLAVER	    ; QUANDO O GP2 DESCER, É TESTADO SE É SLAVE OU MASTER 
	BTFSC	INTCON, T0IF	    ; VERIFICA SE HOUVE ESTOURO DO TIMER 0
	GOTO	INCREMENTA_LIMPA    ; INCREMENTA O CONTADOR DO START_SYNC
	GOTO	START_SYNC	    ; SE NÃO, REINICIA
	
INCREMENTA_LIMPA
	BTFSC	CONTADOR_START_SYNC, 2	; VERIFICA E PASSOU DE 3 O INCREMTETO, SE SIM, SAI
	    GOTO	SAI_INT
	INCF	CONTADOR_START_SYNC
	BCF	INTCON, T0IF
	GOTO	INICIO_START_SYNC
	
VERIFICA_SLAVER
	MOVLW	0x40			; ENDEREÇO APONTADO CASO SEJA SLAVE NA MEMORIA
	MOVWF	FSR			; PONTEIRO APONTANDO NO ENDEREÇO 0x30 NA MEMÓRIA RAM
	MOVLW	.3			; CONTADOR DE BYTES, REFERENTE AO BYTE 0, MELHORAR ESSE DADO
	MOVWF	CONTADOR_BYTES
	DECFSZ	CONTADOR_START_SYNC	; DECREMENTA O CONTADOR E VERIFICA SE ELE É ZERO,
	GOTO	VERIFICA_MASTER		; SE FOR ZERO, O TIMER ZERO ESTOUROU 1 VEZ SÓ, ENTÃO É SLAVE
	;BSF	PROPRIETARIO, 0		; BIT 0 REFERENTE AO SLAVER
	BCF	PROPRIETARIO, 0		; LIMPA QUE NÃO É MASTER
	;BSF	GPIO,GP0	
	GOTO	START_BIT_INICIO	; INICIA A VERIFICAÇÃO DO START BIT
	
VERIFICA_MASTER				; VERIFICA SE É MASTER
	DECFSZ	CONTADOR_START_SYNC
	GOTO	SAI_INT			; DEU PROBLEMA, NÃO É UM START_SYNC
	;BCF	PROPRIETARIO, 0		; LIMPA QUE NÃO É SLAVE
	BSF	PROPRIETARIO, 0		; BIT 1 REFERENTE AO MASTER
	BSF	PORTA, RA6
	;BSF	GPIO,GP0
	;MOVLW	0x40

	;MOVWF	FSR
	;MOVLW	.4
	;MOVWF	CONTADOR_BYTES
	GOTO	START_BIT_INICIO
;==================================================
START_BIT_INICIO

	;BSF	GPIO, GP1		; CASO O BARRAMENTO NÃO SUBA, ELE FOI TRATADO ANTERIORMENTE NO START_SYNC. SE O BARRAMENTO FICAR EM LOW, TODO O BARRAMENTO ESTARA COM PROBLEMAS
	BTFSS	PORTB, RB0;GP2		; ESPERA O BARRAMENTO SUBIR
	GOTO	START_BIT_INICIO	
START_BIT_CONFIGURA			; CONFIGURA O REINICIO DA CONTAGEM DO START BIT PARA O CONTADOR QUANDO O TIMER ZERO ESTOURAR
	BCF	INTCON, T0IF
	MOVLW	.145			; O TMR0 ESTOURARÁ A CADA 130 US
	MOVWF	TMR0
START_BIT
	BTFSS	PORTB, RB0;GP2
	GOTO	VERIFICA_START_BIT
	BTFSC	INTCON, T0IF		; VERIFICA SE O TIMER ZERO ESTOUROU
	GOTO	INCREMENTA_START_BIT	; SE SIM, INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT		; SE NÃO, CONTINUA A CONTAGEM
INCREMENTA_START_BIT
	 ;BSF	GPIO, GP4
	BTFSC	CONTADOR_START_BIT, 1	; TESTA SE HOUVE MAIS DE UM ESTOURO DO TIMER0, SE SIM, SAI DA INTERRUÇÃO
	    GOTO	SAI_INT
	INCF	CONTADOR_START_BIT	; INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT_CONFIGURA 
VERIFICA_START_BIT

	DECFSZ	CONTADOR_START_BIT	; VERIFICA SE HOUVE APENAS UM ESTOURO NO TIMER 0 NA SUBIDA DO START BIT
	GOTO	SAI_INT			; SE HOUVE MAIS DE 1 OU MENOS, NÃO CARACTERIZA UM START BIT E SAI DA INTERRUPÇÃO
	GOTO	START_BIT_LOW_INICIO		; SE HOUVE APENAS 1 ESTOURO, CONTINUA A VERIFICAÇÃO PARA O TEMPO EM LOW

	
START_BIT_LOW_INICIO			; CODIGO PARECIDO COM A VERIFICAÇÃO DO TEMPO EM ALTA DO START BIT
	; BSF	GPIO, GP4
	BCF	INTCON, T0IF		; MAS AGORA É TESTADO COM O TEMPO EM LOW
	MOVLW	.145
	MOVWF	TMR0
START_BIT_LOW
	BTFSC	PORTB, RB0;GP2
	GOTO	SAI_INT			
	BTFSC	INTCON, T0IF
	GOTO	ESPERA_SUBIDA_START_BIT
	GOTO	START_BIT_LOW
	
ESPERA_SUBIDA_START_BIT
	BCF	INTCON, T0IF
	MOVLW	.225			; O TMR0 ESTOURARÁ A CADA 130 US
	MOVWF	TMR0
ESPERA_SUBIDA_ST	
	BTFSC	PORTB, RB0;GP2
	GOTO	LER_BITS
	BTFSC	INTCON, T0IF
	GOTO	SAI_INT			; SE O BARRAMENTO NÃO SUBIR NO INTERVALO DE TEMPO DADO, NÃO CARACTERIZA UM START BIT
	GOTO	ESPERA_SUBIDA_ST
	
;====================================
	
LER_BITS
	;BSF	GPIO, GP2 ; APAGAR
	BCF	INTCON, T0IF		; LIMPA A FLAG DE ESTOURO DO TIMER ZERO
	MOVLW	.232;.234		; O TIMER ZERO ESTOURARÁ A CADA 30 US (BASE), QUANDO HOUVER O ESTOURO, É VERIFICADO
	MOVWF	TMR0			; O ESTADO DO BARRAMENTO, SE O BARRAMENTO ESTIVER EM ALTA, SIGNIFICA QUE O BARRAMENTO AINDA NÃO BAIXOU, OU SEJA, CARACTERIZA O BIT 1 (40(H)) > 30 US
	MOVLW   .248			; PASSA O VALOR PARA O MONITORA_BITS 
	MOVWF	MONITORA_BITS		; QUANDO CHEGAR EM 255 ESTOURA
LER_BITS_CONTINUA			; CASO O BARRAMENTO ESTEJA EM LOW, SIGNIFICA QUE O BARRAMENTO JÁ FOI PARA LOW, OU SEJA, O BIT LIDO É O ZERO (20(H) + 10(L)) = 30 US
	;BTFSS	GPIO, GP2
	;GOTO	VERIFICA_1_0
	;BTFSC	INTCON, T0IF		; VERIFICA SE HOUVE ESTOURO DO TIMER ZERO
	;GOTO	VERIFICA_1_0		; VERIFICA SE O BIT LIDO É ZERO OU UM
	INCFSZ	MONITORA_BITS		; INCREMENTA, SE ESTOURAR, É SINAL QUE HOUVE ALGUM ERRO, E O PROGRAMA SAI
	    GOTO    $+2			; SE NÃO ESTOURAR, CONTINUA
	    GOTO    SAI_INT		; SE ESTOURAR, SAI DA INTERRUPÇÃO
	
	BTFSC	PORTB, RB0;GP2
	    GOTO	LER_BITS_CONTINUA
	    GOTO	VERIFICA_1_0
	
	
	
;INCREMENTA_CONTADOR_BITS
;	INCF	CONTADOR_TEMPO_BITS
;	GOTO	LER_BITS
VERIFICA_1_0		    ; VERIFICA SE É O BIT 1 OU 0
	BTFSS	INTCON, T0IF    ;GPIO, GP2
	GOTO	BIT_0
	GOTO	BIT_1

BIT_0
	BCF	STATUS, C
	RLF	INDF
	
	
	
	DECFSZ	CONTADOR_BITS		; DECREMENTA O CONTADOR DE BITS 
	GOTO	ESPERA_BIT_0_MUDAR	; SE NÃO FOR ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	INCF	FSR			; SE ACABOU, INCREMENTA O PONTEIRO PARA O PROXIMO ENDEREÇO DE MEMÓRIA	    
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES		; DECREMENTA O CONTADOR DE BYTES QUE TEM QUE SER LIDO
	GOTO	ESPERA_BIT_0_MUDAR	; CASO NÃO SEJA ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	GOTO	CONCLUIDA_LEITURA	; CASO SEJA ZERO, A LEITURA DOS DADOS DO BARRAMENTO ESTÁ FINALIZADO.
	
ESPERA_BIT_0_MUDAR		
	BTFSS	PORTB, RB0;GP2
	GOTO	ESPERA_BIT_0_MUDAR
	GOTO	LER_BITS

BIT_1
	BSF	STATUS, C
	RLF	INDF
	
	
	
	
	DECFSZ	CONTADOR_BITS
	GOTO	ESPERA_BIT_1_MUDAR
	INCF	FSR
	;BSF	GPIO, GP4
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES
	GOTO	ESPERA_BIT_1_MUDAR
	GOTO	CONCLUIDA_LEITURA
	
ESPERA_BIT_1_MUDAR
	;BTFSC	GPIO, GP2
	;GOTO	ESPERA_BIT_1_MUDAR

	BTFSS	PORTB, RB0;GP2
	GOTO	$-1
	GOTO	LER_BITS
	
CONCLUIDA_LEITURA
	;BSF	BARRAMENTO, 6	; SINALIZA QUE A LEITURA FOI FINALIZADA
	BTFSC	DADO, 7
	    GOTO    COLISAO	; SE HOUVER COLISÃO, TEM QUE LIGAR ALERTA, FREIO E PARAR
	BTFSS	PROPRIETARIO, 0 ; É MASTER?
	    GOTO    SAI_INT
	    ;GOTO    PASSA_DADO_SINALIZACAO
	;+BSF	PORTA, RA6
	; TESTA SE O VALOR NO DADO É MENOR DO QUE 15 [ X01XXXXX ] -> ILUMINAÇÃO 
	;MOVLW	B'01100000'	; PASSA A MASCARA PARA O WORK PARA FAZER O AND
	;ANDWF	DADO, 0		; FAÇO O AND COM O DADO, PARA PEGAR SOMENTE OS BITS 5 E 6 E SALVAR NO WORK O RESULTADO
	;XORLW	B'00100000'	; FAÇO OUTRO XOR COM O WORK PARA CHECAR SE SOMENTE O BIT 5 É 1, CASO SEJA, O RESULTADO É ZERO
	BTFSS	DADO, 6		; TESTA SE O BIT 6 ESTA EM 1
	    GOTO    TESTA_SENSORES	; SE NÃO DEU, O VALOR NÃO INTERESSA AO SUBSISTEMA DE SINALIZAÇÃO
	    GOTO    PASSA_DADO_SINALIZACAO

TRATA_SENSORES
	MOVLW	B'11110000'
	ANDWF	PORTB, 0	; PEGA OS VALORES REFERENTE DO RB<7:4> E JOGA NO WORD 
	MOVWF	VALORES_SENSORES; SALVA ESSES VALORES NO VALOR SENSORES
	BSF	BARRAMENTO, 7	; SINALIZA QUE HOUVE UMA MUDANÇA NOS VALORES DOS SENSORES
	BCF	INTCON, RBIF	; LIMPA A SINALIZAÇÃO DE INTERRUPÇÃO DOS SENSORES, SO LIMPA ESSA FLAG AQUI
	GOTO	SAI_INT
	

TESTA_SENSORES
	; TESTA SE O VALOR NO DADO É MENOR DO QUE 15 [ X01XXXXX ] -> ILUMINAÇÃO 
	MOVLW	B'11110000'	; PASSA A MASCARA PARA O WORK PARA FAZER O AND
	ANDWF	DADO, 0		; FAÇO O AND COM O DADO, PARA PEGAR SOMENTE OS BITS 5 E 6 E SALVAR NO WORK O RESULTADO
	XORLW	B'00010000'	; FAÇO OUTRO XOR COM O WORK PARA CHECAR SE SOMENTE O BIT 5 É 1, CASO SEJA, O RESULTADO É ZERO
	BTFSS	STATUS, Z	; TESTA SE O RESULTADO DEU ZERO
	    GOTO    SAI_INT	; SE NÃO DEU, O VALOR NÃO INTERESSA AO SUBSISTEMA DE TRAÇÃO
	    GOTO    PASSA_DADO_SENSORES
COLISAO
	MOVLW	B'00011100'		; FREIO E ALERTA ACIONADOS
	IORWF	DADO_SINALIZACAO, 1	; FAZ O OR COM O ULTIMO DADO ENVIADO AO SUBSISTEMA PARA QUE ACIONE O ALERTA E O FREIO
	BCF	DADO_SINALIZACAO, 5	; TESTE
	MOVF	DADO_SINALIZACAO, W
	MOVWF	ESTADO_SINALIZACAO
	BSF	BARRAMENTO, 5
	BTFSC	PORTA, RA2
	    BSF	    PORTA, RA3
	BTFSS	PORTA, RA2
	    BCF	    PORTA, RA3
	
	BSF	ALERTA_ON, 0	    ; SINALIZA QUE O ALERTA TEM QUE SER INICIALIZADO ( SINCRONIZADO )
	    
	GOTO	SAI_INT
PASSA_DADO_SINALIZACAO			; CASO SEJA ZERO, O VALOR DO DADO É PASSADO PARA A VARIAVEL DADO_LIDO
	MOVF	DADO, W
	MOVWF	DADO_SINALIZACAO	; PASSA O DADO LIDO NO BARRAMENTO PARA A VARIAVEL DADO_LIDO
	BTFSS	DADO_SINALIZACAO, 5	; TESTA SE É REQUISIÇÃO
	    MOVWF   ESTADO_SINALIZACAO
	MOVLW	B'00011000'
	ANDWF	DADO_SINALIZACAO, 0
	XORLW	B'00011000'
	BTFSS	STATUS, Z
	    GOTO    SAI_INT
	;BSF	BARRAMENTO, 5		; SINALIZA QUE HOUVE UM DADO PARA O SUBSISTEMA DE SINALIZAÇÃO
;	BSF	PORTA, RA2
;	BSF	PORTA, RA3
	BTFSC	PORTA, RA2
	    BSF	    PORTA, RA3
	BTFSS	PORTA, RA2
	    BCF	    PORTA, RA3
	GOTO	SAI_INT
	
PASSA_DADO_SENSORES			; CASO SEJA ZERO, O VALOR DO DADO É PASSADO PARA A VARIAVEL DADO_LIDO
	MOVF	DADO, W
	MOVWF	DADO_SENSORES	; PASSA O DADO LIDO NO BARRAMENTO PARA A VARIAVEL DADO_LIDO
	BSF	BARRAMENTO, 7	; SINALIZA QUE HOUVE UM DADO PARA O SUBSISTEMA DE SENSORES
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	CLRF	CONTADOR_START_SYNC
	CLRF	CONTADOR_START_BIT
	BCF	INTCON, INTF		; LIMPA QUE HOUVE INTERRUPÇÃO DO GP2
	BCF	BARRAMENTO, 1
	BCF	FLAG_COLISAO
	BCF	FLAG_COL_START_BIT
	BCF	BARRAMENTO, 6		; LIMPA A FLAG
	BSF	BARRAMENTO, 5
	;BCF	BARRAMENTO, 4
	;BCF	BARRAMENTO, 2
	;CLRF	BARRAMENTO
	;BCF	GPIO, GP4
;	BANK1
;	BSF	TRISB, 0	; COLOCA O RB0 COMO ENTRADA (ALTA IMPEDANCIA)
;	BANK0
	
	
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.
TRATA_DADOS_SINALIZACAO
	; LER E TRATA
	BTFSC	REQUISICAO		; TESTA SE HOUVE UMA REQUISIÇÃO
	    GOTO    REQUISICAO_ILUMINACAO
	; TEM UMA INTERRUPÇÃO AQUI E BUGA 
	;MOVF	DADO_SINALIZACAO, W
	;MOVWF	ESTADO_SINALIZACAO
	
	BTFSC	FAROL			; TESTA O FAROL
	    GOTO    LIGAR_FAROL		; LIGA O FAROL
	    GOTO    DESLIGAR_FAROL	; DESLIGA O FAROL
FIM_FAROL
	BTFSC	RE			; TESTA A RÉ
	    GOTO    LIGAR_RE		; LIGA A LUZ DE RE
	    GOTO    DESLIGAR_RE		; DESLIGA A LUZ DE RE
FIM_RE
	BTFSC	FREIO			; TESTA O FREIO
	    GOTO    FREIO_ACIONADO
	    GOTO    FREIO_DESACIONADO
FIM_FREIO
	
	BTFSS	SETA_ESQUERDA		; TESTA O ALERTA
	    GOTO    FIM_ALERTA
	BTFSC	SETA_DIREITA
	    GOTO    LIGA_ALERTA
	    ;GOTO    DESLIGA_ALERTA
FIM_ALERTA
	BTFSC	SETA_ESQUERDA		; TESTA A SETA ESQUERDA
	    GOTO    LIGA_SETA_ESQUERDA	;
	    GOTO    DESLIGA_SETA_ESQUERDA
FIM_SETA_ESQUERDA
	BTFSC	SETA_DIREITA		; TESTA O FAROL
	    GOTO    LIGA_SETA_DIREITA	;
	    GOTO    DESLIGA_SETA_DIREITA


;----------------------------  
FREIO_ACIONADO
	 ; TRATA O FREIO
	 MOVLW	.99			; PWM EM 99%
	 MOVWF	CCPR1L
	 
	 GOTO	FIM_FREIO
FREIO_DESACIONADO
	 ; TRATA O FREIO
	 MOVLW	PWM_FREIO			; PWM EM 30%
	 MOVWF	CCPR1L
	 
	 GOTO	FIM_FREIO
;----------------------------
LIGAR_FAROL
	 BSF	PORTA, RA0
	 GOTO	FIM_FAROL
DESLIGAR_FAROL
	 BCF	PORTA, RA0
	 GOTO	FIM_FAROL
;------------------------------
LIGAR_RE
	 BSF	    PORTA,  RA1
	 GOTO	    FIM_RE
DESLIGAR_RE
	 BCF	    PORTA,  RA1
	 GOTO	    FIM_RE
;-----------------------------
LIGA_ALERTA
	  ; TRATA O ALERTA
	BTFSC	    ALERTA_ON, 0
	    GOTO    SINCRONIZA_LEDS	    ; SINALIZA QUE O ALERTA TEM QUE SER INICIALIZADO ( SINCRONIZADO )
FIM_SINCRONIZA_LEDS
	
	BTFSS	    PIR1, TMR1IF
	    GOTO	FIM_TRATA_SINALIZACAO
	    ;GOTO	MAIN
	MOVLW	B'00001100'
	XORWF	PORTA, 1
	GOTO	INICIALIZA_TIMER1
SINCRONIZA_LEDS
	BSF	PORTA, RA2
	BSF	PORTA, RA3
	BCF	ALERTA_ON, 0		    ; SINALIZA QUE JA FOI SINCRONIZADO OS LEDS
	GOTO	FIM_SINCRONIZA_LEDS

DESLIGA_ALERTA
	BCF	PORTA, RA2
	BCF	PORTA, RA3
	BSF	ALERTA_ON, 0	    ; SINALIZA QUE O ALERTA TEM QUE SER INICIALIZADO ( SINCRONIZADO )
	GOTO	FIM_ALERTA
;---------------------------------
LIGA_SETA_ESQUERDA
	BCF	    PORTA, RA3			; DESLIGA A SETA DIREITA SEMPRE
	BTFSS	    PIR1, TMR1IF
	    GOTO	FIM_TRATA_SINALIZACAO
	    ;GOTO	MAIN
	MOVLW	B'00000100'
	XORWF	PORTA, 1
	; TRATA A SETA ESQUERDA
	GOTO	INICIALIZA_TIMER1
DESLIGA_SETA_ESQUERDA
	BCF	PORTA, RA2
	GOTO	FIM_SETA_ESQUERDA
	
LIGA_SETA_DIREITA
	BCF	    PORTA, RA2			; DESLIGA A SETA ESQUERDA SEMPRE
	BTFSS	    PIR1, TMR1IF
	    GOTO	FIM_TRATA_SINALIZACAO
	    ;GOTO	MAIN
	MOVLW	B'00001000'
	XORWF	PORTA, 1
	
	; TRATA A SETA DIREITA
	GOTO	INICIALIZA_TIMER1
DESLIGA_SETA_DIREITA
	BCF	PORTA, RA3
	GOTO	FIM_TRATA_SINALIZACAO
	;GOTO	MAIN
;------------------------------------
INICIALIZA_TIMER1
	MOVLW	B'00001011'
	MOVWF	TMR1H
	MOVLW	B'11011011'
	MOVWF	TMR1L
	BCF	PIR1, TMR1IF
	
	GOTO	FIM_TRATA_SINALIZACAO
	;GOTO	MAIN
	
REQUISICAO_ILUMINACAO
	;MOVF	ESTADO_SINALIZACAO,W
	;MOVWF	DADO
	; ENVIAR ESSE DADO NO BARRAMENTO
	CALL	VERIFICA_BARRAMENTO ;   LER BARRAMENTO PARA SABER SE ESTÁ OCUPADO OU NÃO
	GOTO	ENVIA_DADOS
	; TRATA DA REQUISIÇÃO DA ILUMINAÇÃO
	GOTO	MAIN
;===============================================================
TRATA_DADOS_SENSORES
	; TRATA DADOS DA FAIXA
	GOTO	MAIN
	
	
LE_EEPROM
;LER DADO DA EEPROM, CUJO ENDEREÇO É INDICADO EM W
;DADO LIDO RETORNA EM W
	ANDLW	.127		;LIMITA ENDEREÇO MAX. 127
	BANK1				;ACESSO VIA BANK 1
	MOVWF	EEADR		;INDICA O END. DE LEITURA
	BSF		EECON1,RD	;INICIA O PROCESSO DE LEITURA
	MOVF	EEDATA,W	;COLOCA DADO LIDO EM W
	BANK0				;POSICIONA PARA BANK 0
	RETURN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
	
INICIO
	BANK1			;ALTERA PARA O BANCO 1
	MOVLW	B'11110001' 	;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISB		;COMO SAÍDAS
	MOVLW	B'00100000'
	MOVWF	TRISA		; INICIALIZA PORTA
	MOVLW	B'10001000'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
;	MOVLW	B'11011000'
;	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	;CALL	3FFH
	;MOVWF	OSCCAL
	MOVLW	.100
	MOVWF	PR2		; PERIODO DO PWM
	BANK0			;RETORNA PARA O BANCO
	MOVLW	B'00001100'
	MOVWF	CCP1CON
	MOVLW	PWM_FREIO      
	MOVWF	CCPR1L		; DUTY CICLE
	MOVLW	B'00000100'	; HABILITA O TIMER2
	MOVWF	T2CON		; HABILITA O TIMER2


	MOVLW	B'00110001'
	MOVWF	T1CON		; HABILITANDO O TIMER 1 - 1:8	
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	;CLRF	GPIO
	;MOVLW	.0
	;MOVWF	TMR0
	;BCF	INTCON, INTF 
	
	;BSF	PORTB, RB1
	
	MOVLW	.8
	MOVWF	CONTADOR_BITS
;	CLRF	CONTA_PROTOCOLOL
;	CLRF	CONTA_PROTOCOLOH
	MOVLW	.9
	MOVWF	BITS
;--------------------------------------
	MOVLW	.0
	CALL	LE_EEPROM
	MOVWF	BYTE_0
;--------------------------------------
	MOVLW	.1
	CALL	LE_EEPROM
	MOVWF	ENDERECO_SENSORES	;   2	
;--------------------------------------
	MOVLW	.2
	CALL	LE_EEPROM
	MOVWF	ENDERECO_SINALIZACAO	;   5
;--------------------------------------
	MOVLW	B'00000010'
	;MOVWF	DADOS
	CLRF	BARRAMENTO
	CLRF	VALORES_SENSORES
	MOVWF	PORTB
	MOVLW	B'01000000'
	MOVWF	ESTADO_SINALIZACAO
	MOVWF   DADO_SINALIZACAO
	;CLRF	PORTB 
	CLRF	PORTA
	
	;BSF	GPIO, GP5
	
	;BCF	GPIO, GP0   ;APENAS PARA SIMULAÇÃO, APAGAR AQUI <----
	MOVLW	B'11011000'
	MOVWF	INTCON	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	CALL	DELAY100MS
	CALL	DELAY100MS
; * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

; RB0 -> LER O BARRAMENTO
; RB1 -> ESCREVE NO BARRAMENTO
;
; RA0 -> FAROL
; RA1 -> RÉ
; RB3 -> PWM -> FREIO
; RA2 -> SE
; RA3 -> SD
;

MAIN
	;CLRF	ESTAGIO		; TEM QUE LIMPAR, SE NÃO FICA ENVIANDO SO 1 BYTE
	;MOVF	DADO, W
	;BCF	PORTA, RA6
	CLRF	ESTAGIO
	;MOVWF	PORTB
;	BTFSC	BARRAMENTO, 7	; HÁ ALGUM DADO PARA SER ENVIADO NO BARRAMENTO REFERENTE AOS SENSORES?
;	    GOTO    ENVIAR_SENSORES ; SIM
	    
	

	GOTO	TRATA_DADOS_SINALIZACAO
FIM_TRATA_SINALIZACAO
	BTFSC	BARRAMENTO, 7	; HÁ ALGUM DADO PARA SER ENVIADO NO BARRAMENTO REFERENTE AOS SENSORES?
	    GOTO    ENVIAR_SENSORES ; SIM
	    GOTO	MAIN
	CALL	DELAY100MS
ENVIAR_SENSORES
	CALL	VERIFICA_BARRAMENTO ;   LER BARRAMENTO PARA SABER SE ESTÁ OCUPADO OU NÃO
	GOTO	ENVIA_DADOS
FIM_ENVIA_DADOS
;BANK1
;BSF	TRISB, 0    ; SETA O RB0 COMO ENTRADA
;BANK0
	MOVLW	B'11011000'	; HABILITA A INTERRUPÇÃO APOS ENVIAR OS DADOS
	MOVWF	INTCON
	;MOVLW	B'11010000'	; HABILITA A INTERRUPÇÃO APOS ENVIAR OS DADOS
	;BCF	INTCON, INTF	; LIMPA A FLAG DE INTERRUPÇÃO NO GP2, POIS QUANOD HABILITAR ELA NOVAMENTE, VAI DIRETO PRA INTERRUPÇÃO
	;BSF	INTCON, GIE
	;BSF	INTCON,	PEIE
	;BSF	INTCON,	INTE
	;DEFINE OPÇÕES DE INTERRUPÇÕES
	; TO DO
	GOTO	MAIN
	
	
;=============================================================
VERIFICA_BARRAMENTO		; VERIFICO SE O BARRAMENTO ESTÁ LIVRE POR 200 US
	BSF	PORTA, RA7
	BSF	INTCON, GIE
	BCF	BARRAMENTO, 5	; LIMPA O SINALIZADOR DE LEITURA DO BARRAMENTO
	; TESTA SE O VALOR LIDO É REFERENTE AO STOP DA COLISAO
	;   SE FOR, TRATAR ESSE DADO
	BCF	INTCON, T0IF
	MOVLW	.40;.20
	MOVWF	TMR0
	BTFSS	PORTB, RB0		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	
VERIFICA_BARRAMENTO_0
	BTFSS	PORTB, RB0		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	BTFSS	INTCON, T0IF
	GOTO	VERIFICA_BARRAMENTO_0
	;BSF	BARRAMENTO, 0	   ; SINALIZO BARRAMENTO LIVRE. (É NECESSÁRIO?)
	BTFSC	BARRAMENTO, 5	; HOUVE UMA LEITURA NO BARRAMENTO?
	 GOTO	VERIFICA_BARRAMENTO
	BCF	PORTA, RA7
	RETURN
;=============================================================
ENVIA_DADOS

;		BTFSC	PORTA, RA7
;		    GOTO    FIM_ENVIA_DADOS
	      BCF	INTCON, GIE		; DESABILITA AS INTERRUPÇÕES
	      BCF	INTCON,	PEIE
	      BCF	INTCON,	INTE
	      BCF	INTCON, RBIE
	;===========
	;BANK1
        ;BCF	TRISB, 0    ; SETA O RB0 COMO SAIDA
	;BANK0
	      

	
	;CLRF	INTCON		    ;	DESABILITA A INTERRUPÇÃO
	;MOVLW	0X00
	MOVLW	0X03
	MOVWF	BYTE_0
	
	BTFSC	BARRAMENTO,7	    ; VERIFICO SE O ENVIO É DOS SENSORES
	    GOTO    PREPARA_SENSORES
	
	MOVF	ENDERECO_SINALIZACAO, W  ;	MOVO O ENDEREÇO DO SUBSISTEMA QUE ENVIARÁ DOS DADOS
	MOVWF	ENDERECO	    ;	PARA O ENDEREÇO QUE SERÁ LIDO
	MOVF	ESTADO_SINALIZACAO, W
	MOVWF	DADO
	GOTO	ENVIAR_OK

	
PREPARA_SENSORES
	MOVF	VALORES_SENSORES, W
	MOVWF	DADO
	SWAPF	DADO		    ; SWAP PARA INVERTER A POSIÇÃO E FICAR COM O FORMATO DE ENVIO DO DADO REFERENTE A DETECÇÃO DE FAIXA
	BSF	DADO,4
	MOVF	ENDERECO_SENSORES,W
	MOVWF	ENDERECO
	
ENVIAR_OK
	      
	    MOVLW	0x3F			; ENDEREÇO APONTADO PARA O ENREREÇO RESERVADO PARA LEITURA DOS DADOS 
						; PARA SER INCREMENTADO POR IGUAL NO ENVIO DOS BYTES
	    MOVWF	FSR			; PONTEIRO
	    MOVLW	.3
	    MOVWF	CONTADOR_BYTES
	    
	    BTFSS	PORTB, RB0		; TESTE
	       GOTO	MAIN
	    
	    CALL	START_SYNC_SLAVE	; PASSA 250 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	    GOTO	START_BIT_ENVIA
FIM_START_BIT
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 1	    ; SINALIZA QUE É O ENVIO DO BYTE 0
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_BYTE_0
		NOP
		NOP
		;NOP
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 2	    ; SINALIZA QUE É O ENVIO DO ENDEREÇO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_ENDERECO
		NOP
		NOP
		;NOP
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
			;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 3	    ; SINALIZA QUE É O ENVIO DO DADO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_DADO
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		CALL	DELAY_US
		BSF	PORTB, RB1	    ; COLOCA O BARRAMENTO EM ALTA
		
		BTFSC	BARRAMENTO, 7	    ; OS DADOS ENVIADOS ERAM DOS SENSORES?
		    GOTO    ENVIOU_SENSORES ; TRATA
		BTFSC	REQUISICAO
		    GOTO    REQUISICAO_ENVIADA
		GOTO	FIM_ENVIA_DADOS
REQUISICAO_ENVIADA
		;BCF	REQUISICAO	    ; QUANDO HOUVER UMA REQUISIÇÃO, ENVIA UMA UNICA VEZ O DADO
		MOVF	ESTADO_SINALIZACAO, W
		MOVWF	DADO_SINALIZACAO
		GOTO	FIM_ENVIA_DADOS
ENVIOU_SENSORES
		BCF	BARRAMENTO, 7
		GOTO	FIM_ENVIA_DADOS	    ; CASO TAMBÉM TENHA TIDO UMA REQUISIÇÃO, O BIT DE REQUISIÇÃO NÃO FOI LIMPO
					    ; LOGO, O DADO SERÁ REENVIADO.
	
START_BIT_ENVIA
	;DELAY DE 50 US EM ALTA
	BSF	PORTB, RB1
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	;NOP
	NOP
	NOP
	NOP
	NOP
	;NOP
	;NOP
	NOP
        ;BANK1
	;BSF	TRISB, 0
	;BANK0
	BTFSS	PORTB, RB0;GP2
	    GOTO    COLISAO_START_BIT	; SE HOUVER COLISÃO, TRATAR OS DADOS REFENTE A ELA
        ;BANK1
	;BCF	TRISB, 0 ; SAIDA, BARRAMENTO EM LOW
	;BANK0
	;BSF	PORTB, RB0
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	;NOP
	NOP
	NOP
	
	; DELAY DE 150 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
;BANK1
;BCF	TRISB, 0    ; SAIDA, BARRAMENTO EM LOW
;BANK0
	BCF	PORTB, RB1
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	;NOP
	;NOP
	;NOP
	;NOP
	;NOP
	NOP
	NOP
	NOP
	
	GOTO	FIM_START_BIT
	

ENVIA_BYTE 
    BTFSS   INDF, 7
	GOTO	ENVIA_0
	GOTO	ENVIA_1

ENVIA_0
;	BANK1
;	BSF	TRISB, 0    ; ENTRADA, BARRAMENTO EM ALTA
;	BANK0
	BSF	PORTB, RB1
	;CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	;NOP
	RLF	INDF	    
	
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    PORTB, RB1		; FICA EM BAIXA O BARRAMENTO
;	BANK1
;	BCF	TRISB, 0    ; SAIDA, BARRAMENTO EM BAIXA
;	BANK0
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0

ENVIA_1
;	BANK1
;	BSF	TRISB, 0    ;ENTRADA, BARRAMENTO EM ALTA
;	BANK0
	BSF	PORTB, RB1
	RLF	INDF	
	; PASSA 30 US EM ALTA
	
	BTFSS	PORTB, RB0;GP2		; TESTA SE O BARRAMENTO NÃO ESTÁ COM COLISÃO
	    GOTO    FIM_ENVIA_DADOS	; TRATAR COLISAO BITS
        ;BANK1
	;BSF	TRISB, 0
	;BANK0
	NOP
	NOP
	NOP
	NOP
	BTFSS	PORTB, RB0;GP2
	    GOTO    FIM_ENVIA_DADOS	; SE HOUVER COLISÃO NESSE PONTO, É ERRO, NÃO DEVERIA TER, TRATAR OS DADOS REFENTE A ELA
	CALL	DELAY_US
        ;BANK1
	;BCF	TRISIO, 2
	;BANK0
	;BSF	GPIO, GP2
	;BANK1
	;BSF	TRISIO, 2
	;BANK0
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	;NOP
	;NOP
	;NOP
	;NOP
	;RLF	INDF			; ROTACIONA O DADO;	BTFSS	GPIO, GP2		; TESTA SE O BARRAMENTO NÃO ESTÁ COM COLISÃO
;	    GOTO    COLISAO_ENVIAR_BITS	; TRATAR COLISAO BITS
	; PASSA MAIS 10 US EM ALTA APOS CHECAR

	BTFSS	PORTB, RB0;GP2
	    GOTO    COLISAO_ENVIAR_BITS	; SE HOUVER COLISÃO, TRATAR OS DADOS REFENTE A ELA
        ;BANK1
	;BCF	TRISB, 0
	;BANK0
	;BSF	PORTB, RB0
	NOP
	NOP
	NOP
	NOP
	;NOP
	NOP
	NOP
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    PORTB, RB1		; FICA EM BAIXA O BARRAMENTO
;	BANK1
;	BCF	TRISB, 0    ; SAIDA, BARRAMENTO EM BAIXA
;	BANK0
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0
;==============================
TEMPO_EM_BAIXA
;	BANK1
;	BCF	TRISB, 0    ; SAIDA, BARRAMENTO EM BAIXA
;	BANK0
	BCF	PORTB, RB1
	; PASSA 20 US EM BAIXA
	;CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	GOTO	ENVIA_BYTE
;===============================
COLISAO_START_BIT
	
	BSF	FLAG_COL_START_BIT		; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT
	BSF	FLAG_COLISAO		; SINALIZO QUE HOUVE UMA COLISÃO
	BCF	PORTB, RB1
	MOVLW	B'11011000'
	MOVWF	INTCON					;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
	
COLISAO_ENVIAR_BITS								
	BCF	INDF,	7				; SETO O BIT DO REGISTRADOR APONTADO PARA 0, POIS HOUVE COLISAO 
	;BCF	PORTB, RB1
	DECFSZ	CONTADOR_BITS, F			; TEM QUE DECREMENTAR O CONTADOR DE BITS, POIS ELE FOI LIDO JÁ E SERA LIDO OUTRA VEZ CASO NÃO DECREMENTE
	    GOTO	$+2
	    GOTO	MAIN
	BSF	FLAG_COL_ENVIAR_BIT			; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT NO REGISTRADOR BARRAMENTO
	BSF	FLAG_COLISAO				; SINALIZO QUE HOUVE UMA COLISÃO
	MOVLW	B'11011000'
	MOVWF	INTCON					;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
;====================================
START_SYNC_SLAVE
;	BANK1
;	BCF	TRISB, 0    ; SAIDA
;	BANK0
	BCF	PORTB, RB1
	; PASSA 250 US EM BAIXA
			;244 cycles
	MOVLW	.82
	MOVWF	DELAY_SYNC
START_SYNC_SLAVE_0
	DECFSZ	DELAY_SYNC, F
	GOTO	START_SYNC_SLAVE_0
	
	;GOTO	$+1
	BSF	PORTB, RB1
;	BANK1
;	BSF	TRISB, 0 ; ENTRADA, BARRAMENTO VAI PRA 1
;	BANK0
	RETURN

DELAY_US
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    
    RETURN
DELAY100MS
			;99993 cycles
	MOVLW	.30
	movwf	CONT_1
	MOVLW	.79
	movwf	CONT_2
DELAY100MS_0
	DECFSZ	CONT_1
	GOTO	$+2
	DECFSZ	CONT_2
	GOTO	DELAY100MS_0
			;3 cycles
	GOTO	$+1
	NOP
			;4 cycles (including call)
	RETURN
    END
