;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                    FEVEREIRO DE 2016                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA


;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		COUNT_SYNC
		
		DELAY_
		BYTE
		
		DADOS
		BITS
		CONT_START_SYNC_MASTER
		DELAY_SYNC
		
		DADO_LIDO
		
		CONT_2
		CONT_1
		BARRAMENTO ; REGISTRADOR DE DADOS SOBRE O BARRAMENTO
		DADO_ENVIAR
		DIRECAO
		
		CONTADOR_START_SYNC
		PROPRIETARIO
		CONTADOR_START_BIT
		CONTADOR_BYTES
		CONTADOR_BITS
		ESTAGIO
		ENDERECO_ENVIAR
		
		;NOVAS VARIÁVEIS

	ENDC			;FIM DO BLOCO DE MEMÓRIA
		
	CBLOCK	0x40
		BYTE_0
		ENDERECO
		DADO
	ENDC
	
	CBLOCK	0x50
		DPNV1	    ; DURAÇÃO DO PULSO VELOCIDADE NORMAL 1
		DPNV2
		DPNV3
		
		DPSV1	    ; DURAÇÃO DO PULSO VELOCIDADE SPORT 1
		DPSV2
		DPSV3
		
		;NOVAS VARIÁVEIS

	ENDC
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA
#DEFINE	FLAG_COL_START_BIT  BARRAMENTO, 3   ; BIT REFERENTE A COLISAO NO START_BIT
#DEFINE	FLAG_COL_ENVIAR_BIT BARRAMENTO, 4   ; BIT REFERENTE A COLISAO AO ENVIAR BIT
#DEFINE	FLAG_COLISAO	    BARRAMENTO, 1   ; BIT REFERENTE A COLISAO
#DEFINE	FLAG_BYTE_0	    ESTAGIO, 1	    ; FLAG REFERENTE AO ESTAGIO DO BYTE_0
#DEFINE	FLAG_ENDERECO	    ESTAGIO, 2	    ; FLAG REFERENTE AO ESTAGIO DO ENDERECO
#DEFINE	FLAG_DADO	    ESTAGIO, 3	    ; FLAG REFERENTE AO ESTAGIO DO DADO
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;A PARTIR DO ENDEREÇO ZERO DA EEPROM, DADOS EM ORDEM ALEATÓRIA
	ORG 0x2100
	DE	0X03,0X03,0X04	; VALORES FIXOS DO SUBSISTEMA DE DIREÇÃO

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP
	BCF	INTCON, T0IF
	;BSF	GPIO, GP4

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES
    BTFSC	FLAG_COLISAO
	GOTO	TRATAR_COLISAO
	GOTO	INICIO_START_SYNC

TRATAR_COLISAO
	BTFSS	    FLAG_COL_START_BIT
	    GOTO    LER_BITS
	    GOTO    INIC_CONT_START_SYNC
	    
INIC_CONT_START_SYNC
	INCF	CONTADOR_START_SYNC
	MOVLW	.155
	MOVWF	TMR0
	GOTO	START_SYNC
; INTERRUPÇÕES
INICIO_START_SYNC
	MOVLW	.8
	MOVWF	CONTADOR_BITS		; TEM QUE TER ISSO PARA QUE O CONTADOR DE BITS COMECE COM SE NAO ELE FICA PRESO NO LER BITS
	MOVLW	.53;.55		    ; SERÁ VISTO QUANTAS VEZES O TIMER0 ESTOURARÁ
	MOVWF	TMR0
START_SYNC
	BTFSC	GPIO, GP2
	GOTO	VERIFICA_SLAVER	    ; QUANDO O GP2 DESCER, É TESTADO SE É SLAVE OU MASTER 
	BTFSC	INTCON, T0IF	    ; VERIFICA SE HOUVE ESTOURO DO TIMER 0
	GOTO	INCREMENTA_LIMPA    ; INCREMENTA O CONTADOR DO START_SYNC
	GOTO	START_SYNC	    ; SE NÃO, REINICIA
	
INCREMENTA_LIMPA
	BTFSC	CONTADOR_START_SYNC, 2	; VERIFICA E PASSOU DE 3 O INCREMTETO, SE SIM, SAI
	    GOTO	SAI_INT
	INCF	CONTADOR_START_SYNC
	BCF	INTCON, T0IF
	GOTO	INICIO_START_SYNC
	
VERIFICA_SLAVER
	MOVLW	0x40			; ENDEREÇO APONTADO CASO SEJA SLAVE NA MEMORIA
	MOVWF	FSR			; PONTEIRO APONTANDO NO ENDEREÇO 0x30 NA MEMÓRIA RAM
	MOVLW	.1			; CONTADOR DE BYTES, REFERENTE AO BYTE 0, MELHORAR ESSE DADO
	MOVWF	CONTADOR_BYTES
	DECFSZ	CONTADOR_START_SYNC	; DECREMENTA O CONTADOR E VERIFICA SE ELE É ZERO,
	GOTO	VERIFICA_MASTER		; SE FOR ZERO, O TIMER ZERO ESTOUROU 1 VEZ SÓ, ENTÃO É SLAVE
	BSF	PROPRIETARIO, 0		; BIT 0 REFERENTE AO SLAVER
	;BSF	GPIO,GP4	
	GOTO	START_BIT_INICIO	; INICIA A VERIFICAÇÃO DO START BIT
	
VERIFICA_MASTER				; VERIFICA SE É MASTER
	DECFSZ	CONTADOR_START_SYNC
	GOTO	SAI_INT			; DEU PROBLEMA, NÃO É UM START_SUMC
	BSF	PROPRIETARIO, 1		; BIT 1 REFERENTE AO MASTER
	;BSF	GPIO,GP4
	;MOVLW	0x40
	;MOVWF	FSR
	;MOVLW	.4
	;MOVWF	CONTADOR_BYTES
	GOTO	START_BIT_INICIO
;==================================================
START_BIT_INICIO

	;BSF	GPIO, GP5		; CASO O BARRAMENTO NÃO SUBA, ELE FOI TRATADO ANTERIORMENTE NO START_SYNC. SE O BARRAMENTO FICAR EM LOW, TODO O BARRAMENTO ESTARA COM PROBLEMAS
	BTFSS	GPIO, GP2		; ESPERA O BARRAMENTO SUBIR
	GOTO	START_BIT_INICIO	
START_BIT_CONFIGURA			; CONFIGURA O REINICIO DA CONTAGEM DO START BIT PARA O CONTADOR QUANDO O TIMER ZERO ESTOURAR
	BCF	INTCON, T0IF
	MOVLW	.145			; O TMR0 ESTOURARÁ A CADA 130 US
	MOVWF	TMR0
START_BIT
	BTFSS	GPIO, GP2
	GOTO	VERIFICA_START_BIT
	BTFSC	INTCON, T0IF		; VERIFICA SE O TIMER ZERO ESTOUROU
	GOTO	INCREMENTA_START_BIT	; SE SIM, INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT		; SE NÃO, CONTINUA A CONTAGEM
INCREMENTA_START_BIT
	 ;BSF	GPIO, GP4
	BTFSC	CONTADOR_START_BIT, 1	; TESTA SE HOUVE MAIS DE UM ESTOURO DO TIMER0, SE SIM, SAI DA INTERRUÇÃO
	    GOTO	SAI_INT
	INCF	CONTADOR_START_BIT	; INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT_CONFIGURA 
VERIFICA_START_BIT

	DECFSZ	CONTADOR_START_BIT	; VERIFICA SE HOUVE APENAS UM ESTOURO NO TIMER 0 NA SUBIDA DO START BIT
	GOTO	SAI_INT			; SE HOUVE MAIS DE 1 OU MENOS, NÃO CARACTERIZA UM START BIT E SAI DA INTERRUPÇÃO
	GOTO	START_BIT_LOW_INICIO		; SE HOUVE APENAS 1 ESTOURO, CONTINUA A VERIFICAÇÃO PARA O TEMPO EM LOW

	
START_BIT_LOW_INICIO			; CODIGO PARECIDO COM A VERIFICAÇÃO DO TEMPO EM ALTA DO START BIT
	; BSF	GPIO, GP4
	BCF	INTCON, T0IF		; MAS AGORA É TESTADO COM O TEMPO EM LOW
	MOVLW	.145
	MOVWF	TMR0
START_BIT_LOW
	BTFSC	GPIO, GP2
	GOTO	SAI_INT			
	BTFSC	INTCON, T0IF
	GOTO	ESPERA_SUBIDA_START_BIT
	GOTO	START_BIT_LOW
	
ESPERA_SUBIDA_START_BIT
	BCF	INTCON, T0IF
	MOVLW	.225			; O TMR0 ESTOURARÁ A CADA 130 US
	MOVWF	TMR0
ESPERA_SUBIDA_ST	
	BTFSC	GPIO, GP2
	GOTO	LER_BITS
	BTFSC	INTCON, T0IF
	GOTO	SAI_INT			; SE O BARRAMENTO NÃO SUBIR NO INTERVALO DE TEMPO DADO, NÃO CARACTERIZA UM START BIT
	GOTO	ESPERA_SUBIDA_ST
	
;====================================
LER_BITS
	;BSF	GPIO, GP1 ; APAGAR
	
	
	BCF	INTCON, T0IF		; LIMPA A FLAG DE ESTOURO DO TIMER ZERO
	MOVLW	.234			; O TIMER ZERO ESTOURARÁ A CADA 30 US (BASE), QUANDO HOUVER O ESTOURO, É VERIFICADO
	MOVWF	TMR0			; O ESTADO DO BARRAMENTO, SE O BARRAMENTO ESTIVER EM ALTA, SIGNIFICA QUE O BARRAMENTO AINDA NÃO BAIXOU, OU SEJA, CARACTERIZA O BIT 1 (40(H)) > 30 US
LER_BITS_CONTINUA			; CASO O BARRAMENTO ESTEJA EM LOW, SIGNIFICA QUE O BARRAMENTO JÁ FOI PARA LOW, OU SEJA, O BIT LIDO É O ZERO (20(H) + 10(L)) = 30 US

	BTFSC	GPIO, GP2
	GOTO	LER_BITS_CONTINUA
	GOTO	VERIFICA_1_0
	
	
	
;INCREMENTA_CONTADOR_BITS
;	INCF	CONTADOR_TEMPO_BITS
;	GOTO	LER_BITS
VERIFICA_1_0		    ; VERIFICA SE É O BIT 1 OU 0
	BTFSS	INTCON, T0IF    ;GPIO, GP2
	GOTO	BIT_0
	GOTO	BIT_1

BIT_0
	BCF	STATUS, C
	RLF	INDF
	
	
	
	DECFSZ	CONTADOR_BITS		; DECREMENTA O CONTADOR DE BITS 
	GOTO	ESPERA_BIT_0_MUDAR	; SE NÃO FOR ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	INCF	FSR			; SE ACABOU, INCREMENTA O PONTEIRO PARA O PROXIMO ENDEREÇO DE MEMÓRIA
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES		; DECREMENTA O CONTADOR DE BYTES QUE TEM QUE SER LIDO
	GOTO	ESPERA_BIT_0_MUDAR	; CASO NÃO SEJA ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	;GOTO	CONCLUIDA_LEITURA
	
	BTFSC	BARRAMENTO, 6
	    GOTO    CONCLUIDA_LEITURA
;PASSA_BYTE_0
	BSF	BARRAMENTO, 6		; SINALIZA QUE O BYTE_0 JÁ FOI LIDO
	DECF	BYTE_0, 1
	MOVF	BYTE_0,W
	MOVWF	CONTADOR_BYTES
	;GOTO	LER_BITS
	
ESPERA_BIT_0_MUDAR		
	BTFSS	GPIO, GP2
	GOTO	ESPERA_BIT_0_MUDAR
	GOTO	LER_BITS

BIT_1
	BSF	STATUS, C
	RLF	INDF
	
	
	
	
	DECFSZ	CONTADOR_BITS
	GOTO	ESPERA_BIT_1_MUDAR
	INCF	FSR
	;BSF	GPIO, GP4
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES
	GOTO	ESPERA_BIT_1_MUDAR
	;GOTO	CONCLUIDA_LEITURA
	
	BTFSC	BARRAMENTO, 6
	    GOTO    CONCLUIDA_LEITURA
;PASSA_BYTE_0
	BSF	BARRAMENTO, 6		; SINALIZA QUE O BYTE_0 JÁ FOI LIDO
	DECF	BYTE_0, 1
	MOVF	BYTE_0,W
	MOVWF	CONTADOR_BYTES
	;GOTO	LER_BITS
	
ESPERA_BIT_1_MUDAR
	BTFSS	GPIO, GP2
	GOTO	$-1
	GOTO	LER_BITS
	
	
CONCLUIDA_LEITURA
	;BSF	BARRAMENTO, 6	; SINALIZA QUE A LEITURA FOI FINALIZADA
	BTFSC	DADO, 7
	    GOTO    PASSA_DADO
	; TESTA SE O VALOR NO DADO É MENOR DO QUE 15 [ X0001XXX ] -> TRAÇÃO 
	MOVLW	B'01111100'	; PASSA A MASCARA PARA O WORK PARA FAZER O AND
	ANDWF	DADO, 0		; FAÇO O AND COM O DADO, PARA PEGAR SOMENTE OS BITS 2, 3, 4, 5 E 6 E SALVAR NO WORK O RESULTADO
	XORLW	B'00000100'	; FAÇO OUTRO XOR COM O WORK PARA CHECAR SE SOMENTE O BIT 2 É 1, CASO SEJA, O RESULTADO É ZERO
	BTFSS	STATUS, Z	; TESTA SE O RESULTADO DEU ZERO
	    GOTO    SAI_INT	; SE NÃO DEU, O VALOR NÃO INTERESSA AO SUBSISTEMA DE TRAÇÃO
PASSA_DADO			; CASO SEJA ZERO, O VALOR DO DADO É PASSADO PARA A VARIAVEL DADO_LIDO
	MOVF	DADO, W
	MOVWF	DADO_LIDO	; PASSA O DADO LIDO NO BARRAMENTO PARA A VARIAVEL DADO_LIDO
	BSF	BARRAMENTO, 5	; SINALIZA QUE HOUVE UM DADO PARA O SUBSISTEMA DE TRAÇÃO
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	CLRF	CONTADOR_START_SYNC
	CLRF	CONTADOR_START_BIT
	BCF	INTCON, INTF		; LIMPA QUE HOUVE INTERRUPÇÃO DO GP2
	BCF	BARRAMENTO, 1
	BCF	FLAG_COLISAO
	BCF	FLAG_COL_START_BIT
	BCF	BARRAMENTO, 6		; LIMPA A FLAG
	;BSF	BARRAMENTO, 5
	;BCF	BARRAMENTO, 4
	;BCF	BARRAMENTO, 2
	;CLRF	BARRAMENTO
	;BCF	GPIO, GP4
	
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.
	
;   FRENTE	-> DIRECAO, 0
;   ESQUERDA	-> DIRECAO, 1
;   DIREITA	-> DIRECAO, 2

TRATAR_DADO
	BTFSC	DADO_LIDO, 7	; TESTA A COLISAO
	    GOTO    FRENTE	; FRENTE É EQUIVALENTE AO MOTOR PARADO PARA A DIREÇÃO
	BTFSC	DADO_LIDO, 1
	    GOTO    VERIFICA_DIR_REQUESICAO
	BTFSC	DADO_LIDO, 0
	    GOTO    ESQUERDA
	    GOTO    FRENTE

;VERIFICA_RE_REQUESICAO	;CHECA SE É PRA IR PARA RÉ OU ESTA PEDINDO O ESTADO DA TRAÇÃO
;	BTFSC	DADO_LIDO, 0
;	    GOTO    REQUISICAO
;	    GOTO    RE
	    
VERIFICA_DIR_REQUESICAO	 ; CHECA SE É F2 OU F3   
	BTFSC	DADO, 0
	    GOTO    REQUISICAO
	    GOTO    DIREITA
;--------------------------------------------------------------------
DIREITA  ;TRATAR PARA QUE VÁ PARA FRENTE COM DIRECAO 1
	; SETAR O PWM EM 30%
	; SETAR O GP5
	BSF	DIRECAO, 2	;00000110
	BCF	GPIO, GP4   ; TEM QUE COLOCAR O GP4 EM LOW !!!
	
	BTFSS	GPIO, GP5
	    GOTO    DIREITA_PRA_ALTA
	    GOTO    DIREITA_PRA_BAIXA
DIREITA_PRA_ALTA		    ; 5 MS EM ALTA
	MOVLW	B'11101100'
	MOVWF	TMR1H
	MOVLW	B'01110111'
	MOVWF	TMR1L
	
	BSF	GPIO, GP5   ; COLOCA EM ALTA
	
	GOTO	OK_TRATAMENTO
DIREITA_PRA_BAIXA		    ; 10 MS EM ALTA
	MOVLW	B'11011000'
	MOVWF	TMR1H
	MOVLW	B'11101111'
	MOVWF	TMR1L
	
	BCF	GPIO, GP5   ; COLOCA EM BAIXA
	
	GOTO	OK_TRATAMENTO
;--------------------------------------------------------------------

;--------------------------------------------------------------------
ESQUERDA  ;TRATAR PARA QUE FAÇA RÉ COM DIRECAO 1
	; SETAR O PWM IGUAL AO DO F1 EM 30%
	; SETAR O GP4
	BSF	DIRECAO, 1
	BCF	GPIO, GP5   ; TEM QUE COLOCAR O GP5 EM LOW !!!!
	
	BTFSS	GPIO, GP4
	    GOTO    ESQUERDA_PRA_ALTA
	    GOTO    ESQUERDA_PRA_BAIXA
ESQUERDA_PRA_ALTA		    ; 5 MS EM ALTA
	MOVLW	B'11101100'
	MOVWF	TMR1H
	MOVLW	B'01110111'
	MOVWF	TMR1L
	
	BSF	GPIO, GP4   ; COLOCA EM ALTA
	
	GOTO	OK_TRATAMENTO
ESQUERDA_PRA_BAIXA		    ; 10 MS EM ALTA
	MOVLW	B'11011000'
	MOVWF	TMR1H
	MOVLW	B'11101111'
	MOVWF	TMR1L

	BCF	GPIO, GP4   ; COLOCA EM BAIXA
	
	GOTO	OK_TRATAMENTO
;--------------------------------------------------------------------
REQUISICAO
	; TRATAR O DADO DE GP4 E GP5 E ENVIAR NO BARRAMENTO
	BTFSS	BARRAMENTO, 5	; VERIFICA SE O DADO JÁ FOI ENVIADO OU NÃO
	    GOTO    OK_TRATAMENTO   ; SE JÁ FOI, NÃO ENVIA
	MOVLW   B'00000100'    
	BTFSC	DIRECAO, 0	; TESTA SE ESTÁ EM FRENTE
	    MOVLW   B'00000100'
	BTFSC	DIRECAO, 1	; TESTA SE ESTÁ PARA ESQUERDA
	    MOVLW   B'00000101'	   
	BTFSC	DIRECAO, 2	; TESTA SE ESTÁ PARA DIREITA
	    MOVLW   B'00000110'
	    
	MOVWF	DADO_ENVIAR
	MOVWF	DADO_LIDO	; RECOLOCO O VALOR QUE ESTAVA NO SUBSISTEMA PARA ELE CONTINUAR E NÃO PARAR
	
	;BCF	PIR1, TMR1IF	; LIMPA A FLAG DO TIMER1
	
	BCF	BARRAMENTO, 5	; SINALIZA QUE FOI TRATADO O DADO
	
	CALL	VERIFICA_BARRAMENTO
	GOTO	ENVIA_DADOS
;--------------------------------------------------------------------
FRENTE
	BSF	DIRECAO, 0
	BCF	GPIO, 0	    ; LIMPANDO AS DUAS PORTAS, A DIREÇÃO FICA PARA FRENTE
	BCF	GPIO, 1
	GOTO	OK_TRATAMENTO
;--------------------------------------------------------------------
OK_TRATAMENTO
	BCF	PIR1, TMR1IF	; LIMPA A FLAG DO TIMER1
	BCF	BARRAMENTO, 5	; SINALIZA QUE O TRATAMENTO DO DADO JÁ OCORREU
	GOTO	MAIN
LE_EEPROM
;LER DADO DA EEPROM, CUJO ENDEREÇO É INDICADO EM W
;DADO LIDO RETORNA EM W
	ANDLW	.127		;LIMITA ENDEREÇO MAX. 127
	BANK1				;ACESSO VIA BANK 1
	MOVWF	EEADR		;INDICA O END. DE LEITURA
	BSF		EECON1,RD	;INICIA O PROCESSO DE LEITURA
	MOVF	EEDATA,W	;COLOCA DADO LIDO EM W
	BANK0				;POSICIONA PARA BANK 0
	RETURN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00011100' ;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		;COMO SAÍDAS
	CLRF	ANSEL 		;DEFINE PORTAS COMO Digital I/O
	MOVLW	B'00001000'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	;MOVLW	B'11010000'
	;MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	CALL	0x3FF
	MOVWF	OSCCAL
	BANK0			;RETORNA PARA O BANCO
	
	MOVLW	B'00000001'
	MOVWF	T1CON			; HABILITANDO O TIMER 1
	
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	CLRF	GPIO
	MOVLW	.0
	MOVWF	TMR0
	BCF	INTCON, INTF 


	BSF	GPIO, GP1
	MOVLW	.9
	MOVWF	BITS
	MOVLW	.0
	CALL	LE_EEPROM
	MOVWF	BYTE_0
	MOVLW	.1
	CALL	LE_EEPROM
	MOVWF	ENDERECO_ENVIAR
	MOVLW	.2
	CALL	LE_EEPROM
	MOVWF	DADO
	MOVLW	B'00000001'
	MOVWF	DADOS
	
	
	;MOVWF	SBYTE_0
	
	;MOVLW	B'00011110'
	;MOVWF	DADO_SLAVER
	
	
	;BCF	GPIO, GP4   ;APENAS PARA SIMULAÇÃO, APAGAR AQUI <----
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    MOVLW	B'11010000'	; HABILITA A INTERRUPÇÃO APOS ENVIAR OS DADOS
    MOVWF	INTCON
    CALL DELAY100MS
    CALL DELAY100MS
    GOTO TRATAR_DADO

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; GP4 -> ESQUERDA
; GP5 -> DIREITA
; GP2 -> LER O BARRAMENTO
; GP1 -> ENVIA NO BARRAMENTO

;   CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
;   CONTADOR_BYTES
;   DADOS_ENVIAR
;   ENDERECO_ENVIAR
MAIN

	CLRF	ESTAGIO
	
	BTFSC	BARRAMENTO, 5		; TESTA SE TEM DADO PARA O SUBSISTEMA DE DIREÇÃO
	    GOTO    TRATAR_DADO		; SOMENTE PARA QUE NÃO FIQUE ENVIANDO O DADO NO BARRAMENTO MAIS DE UMA VEZ
	    
	BTFSC	PIR1, TMR1IF		; VERIFICA SE HOUVE ESTOURO DO TIMER1
	    GOTO	TRATAR_DADO	; SE HOUVER ESTOURO DOS TIMER, MUDAR ESTADO DO PWM


	;CALL	VERIFICA_BARRAMENTO ;   LER BARRAMENTO PARA SABER SE ESTÁ OCUPADO OU NÃO
	;GOTO	ENVIA_DADOS
	GOTO	MAIN
	
FIM_ENVIA_DADOS
	MOVLW	B'11010000'	; HABILITA A INTERRUPÇÃO APOS ENVIAR OS DADOS
	MOVWF	INTCON

	GOTO	MAIN
	
	
;=============================================================
VERIFICA_BARRAMENTO		; VERIFICO SE O BARRAMENTO ESTÁ LIVRE POR 200 US
	MOVLW	B'11010000'	; HABILITA A INTERRUPÇÃO
	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	BCF	INTCON, T0IF
	BCF	BARRAMENTO, 5	; LIMPA O SINALIZADOR DE LEITURA DO BARRAMENTO
	; TESTA SE O VALOR LIDO É REFERENTE AO STOP DA COLISAO
	;   SE FOR, TRATAR ESSE DADO
	MOVLW	.20
	MOVWF	TMR0
	BTFSS	GPIO, GP2		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	
VERIFICA_BARRAMENTO_0
	BTFSC	BARRAMENTO, 5	; HOUVE UMA LEITURA NO BARRAMENTO?
	 GOTO	VERIFICA_BARRAMENTO
	BTFSS	INTCON, T0IF
	GOTO	VERIFICA_BARRAMENTO_0
	;BSF	BARRAMENTO, 0	   ; SINALIZO BARRAMENTO LIVRE. (É NECESSÁRIO?)
	RETURN
;=============================================================
ENVIA_DADOS


	      BCF	INTCON, GIE		; DESABILITA AS INTERRUPÇÕES
	      BCF	INTCON,	PEIE
	      BCF	INTCON,	INTE
	      
	      MOVF	ENDERECO_ENVIAR, W  ;	MOVO O ENDEREÇO DO SUBSISTEMA QUE ENVIARÁ DOS DADOS
	      MOVWF	ENDERECO	    ;	PARA O ENDEREÇO QUE SERÁ LIDO
	      
	     
	      MOVF	DADO_ENVIAR, W	    ; SEPARA O DADO QUE FOI REQUISITADO PARA ENVIAR
	      MOVWF	DADO
	      
	      MOVLW	0X03
	      MOVWF	BYTE_0
	
	    MOVLW	0x3F			; ENDEREÇO APONTADO PARA O ENREREÇO RESERVADO PARA LEITURA DOS DADOS 
						; PARA SER INCREMENTADO POR IGUAL NO ENVIO DOS BYTES
	    MOVWF	FSR			; PONTEIRO
	    MOVLW	.3
	    MOVWF	CONTADOR_BYTES
	    
	    BTFSS	GPIO, GP2		; TESTE
	       GOTO	MAIN
	       
	    CALL	START_SYNC_SLAVE	; PASSA 250 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	    GOTO	START_BIT_ENVIA
FIM_START_BIT
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 1	    ; SINALIZA QUE É O ENVIO DO BYTE 0
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_BYTE_0
		;NOP
		BSF	BARRAMENTO, 6		; SINALIZA QUE O BYTE_0 JÁ FOI LIDO
		NOP
		;NOP
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 2	    ; SINALIZA QUE É O ENVIO DO ENDEREÇO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_ENDERECO
		NOP
		NOP
		;NOP
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
			;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 3	    ; SINALIZA QUE É O ENVIO DO DADO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_DADO
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		CALL	DELAY_US
		BSF	GPIO, GP1	    ; COLOCA O BARRAMENTO LIVRE, DEIXANDO ELE EM ALTA
		
		BCF	BARRAMENTO, 6	    ; LIMPA A FLAG DE LEITURA DO BYTE_0
		
		GOTO	FIM_ENVIA_DADOS
		
		
	
START_BIT_ENVIA
	;DELAY DE 50 US EM ALTA
	BSF	GPIO, GP1
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	;NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	BTFSS	GPIO, GP2
	    GOTO    COLISAO_START_BIT	; SE HOUVER COLISÃO, TRATAR OS DADOS REFENTE A ELA
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	
	; DELAY DE 150 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	BCF	GPIO, GP1
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	
	GOTO	FIM_START_BIT
	

ENVIA_BYTE 
    BTFSS   INDF, 7
	GOTO	ENVIA_0
	GOTO	ENVIA_1

ENVIA_0
	BSF	GPIO, 5
	CALL	DELAY_US
	NOP
	RLF	INDF	    
	
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    GPIO, 5		; FICA EM BAIXA O BARRAMENTO
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0

ENVIA_1
	BSF	GPIO, 5
	; PASSA 30 US EM ALTA
	CALL	DELAY_US
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	RLF	INDF			; ROTACIONA O DADO
	BTFSS	GPIO, GP2		; TESTA SE O BARRAMENTO NÃO ESTÁ COM COLISÃO
	    GOTO    COLISAO_ENVIAR_BITS	; TRATAR COLISAO BITS
	; PASSA MAIS 10 US EM ALTA APOS CHECAR
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    GPIO, 5		; FICA EM BAIXA O BARRAMENTO
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0
TEMPO_EM_BAIXA
	BCF	GPIO, 5
	; PASSA 20 US EM BAIXA
	CALL	DELAY_US
	GOTO	ENVIA_BYTE
COLISAO_START_BIT
	
	BSF	FLAG_COL_START_BIT		; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT
	BSF	FLAG_COLISAO		; SINALIZO QUE HOUVE UMA COLISÃO
	MOVLW	B'11010000'
	MOVWF	INTCON					;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
	
COLISAO_ENVIAR_BITS								
	BCF	INDF,	7				; SETO O BIT DO REGISTRADOR APONTADO PARA 0, POIS HOUVE COLISAO 
	DECFSZ	CONTADOR_BITS, F			; TEM QUE DECREMENTAR O CONTADOR DE BITS, POIS ELE FOI LIDO JÁ E SERA LIDO OUTRA VEZ CASO NÃO DECREMENTE
	    GOTO	$+2
	    GOTO	MAIN
	BSF	FLAG_COL_ENVIAR_BIT			; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT NO REGISTRADOR BARRAMENTO
	BSF	FLAG_COLISAO				; SINALIZO QUE HOUVE UMA COLISÃO
	MOVLW	B'11010000'
	MOVWF	INTCON					;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
	
START_SYNC_SLAVE
	BCF	GPIO, GP1
	; PASSA 250 US EM BAIXA
			;244 cycles
	MOVLW	.82
	MOVWF	DELAY_SYNC
START_SYNC_SLAVE_0
	DECFSZ	DELAY_SYNC, F
	GOTO	START_SYNC_SLAVE_0
	
	GOTO	$+1
	BSF	GPIO, GP1
	RETURN

DELAY_US
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    
    RETURN
DELAY100MS
			;99993 cycles
	MOVLW	.30
	movwf	CONT_1
	MOVLW	.79
	movwf	CONT_2
DELAY100MS_0
	DECFSZ	CONT_1
	GOTO	$+2
	DECFSZ	CONT_2
	GOTO	DELAY100MS_0
			;3 cycles
	GOTO	$+1
	NOP
			;4 cycles (including call)
	RETURN
    END