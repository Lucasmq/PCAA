;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 16F628A                  *
;*                FEITAS POR LUCAS QUEIROZ                         *
;*                    FEVEREIRO DE 2016                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 16F628A                                    *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p16f877a.inc>		    ;ARQUIVO PADRÃO MICROCHIP PARA 16F877A
    __CONFIG _CP_OFF & _CPD_OFF & _DEBUG_OFF & _LVP_OFF & _WRT_OFF & _PWRTE_ON & _WDT_OFF & _HS_OSC & _BODEN_ON
    
; CP - CODE PROTECTION (HABILITA OU DESABILITA LEITURA DA MEMÓRIA DE PROGRAMA).
; DEBUG - DEPURADOR DA PLACA ICD 2 (HABILITA OU DESABILITA DEPURADOR DA PLACA ICD 2).
; PWRTE - POWER UP TIMER (HABILITA OU DESABILITA TEMPORIZADOR QUE AGUARDA 72 ms PARA ESTABILIZAR O PIC).
; WDT - WATCHDOG TIMER ("CÃO DE GUARDA" TEMPORIZADOR QUE RESETA O PIC QUANDO SISTEMA TRAVADO).
; BOREN - BROWN OUT DETECT (SE A ALIMENTAÇÃO VDD FOR MENOR QUE 4V DURANTE 100 MICRO-SEG O PIC RESETA).
; LVP - LOW VOLTAGE PROGRAM (SISTEMA DE PROGRAMAÇÃO EM BAIXA TENSÃO).
; XT - OSCILADOR DO TIPO CRISTAL.

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA


;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		COUNT_SYNC
		TEMP
		PCLATH_TEMP
		FSR_TEMP
		
		W_AUX
		MONITORA_SUBSISTEMAS
		DELAY_
		BYTE
		
		;DADOS
		BITS
		CONT_START_SYNC_MASTER
		DELAY_SYNC
		BARRAMENTO_I2C
		
		DADO_SINALIZACAO
		DADO_SENSORES
		
		MONITORA_BITS
		ESTADO_SINALIZACAO
		ENDERECO_SINALIZACAO
		ENDERECO_SENSORES
		VALORES_SENSORES
		CONT_2
		CONT_1
		BARRAMENTO ; REGISTRADOR DE DADOS SOBRE O BARRAMENTO
		DADO_I2C
		CONT_BYTES_I2C	    ; CONTADOR QUE IRÁ AVISAR QUANDO CHEGAR OS 13 BYTES DO I2C
				    ; O ULTIMO BIT DIZ QUE TEM DADO NOVO OU NÃO 1- SIM | 0- NÃO
		d1
		d2
		CONTADOR_START_SYNC
		PROPRIETARIO
		CONTADOR_START_BIT
		CONTADOR_BYTES
		CONTADOR_BITS
		ESTAGIO
		ENDERECO_ENVIAR
		OPERACIONAL
		TEMPO0
		;NOVAS VARIÁVEIS

	ENDC			;FIM DO BLOCO DE MEMÓRIA
		
	CBLOCK	0x50
		BYTE_0
		ENDERECO
		DADO
	ENDC
	CBLOCK	0x55		; ESTADO LIDO DOS SUBSISTEMAS DO CARRO
		TRACAO
		DIRECAO
		SINALIZACAO
		SENSORES
		COLISAO
	ENDC
	CBLOCK	0x60
		BYTE_0_1
		ENDERECO_1
		DADO_1
	ENDC
	CBLOCK	0X64
		; DADOS RECEBIDOS DO L3
		DADO_NULL
		TRACAO_L3
		DIRECAO_L3
		SINALIZACAO_L3
		SENSORES_L3
		COLISAO_L3
		
	ENDC
	CBLOCK	0x70		    ; CAMPOS DESTINADOS AO PACOTE L3 - 12 BYTES
		SOH		    ; INICIO DO PACOTE
		IDS		    ; IDENTIFICADOR DE ORIGEM
		IDD		    ; IDENTIFICADOR DE DESTINO
		COD		    ; CÓDIGO DE INSTRUÇÃO
		DATA_P1		    ; INFORMAÇAO
		DATA_P2		    ; INFORMAÇAO
		DATA_P3		    ; INFORMAÇAO
		DATA_P4		    ; INFORMAÇAO
		DATA_P5		    ; INFORMAÇAO
		DATA_P6		    ; INFORMAÇAO
		PAD		    ; ENCHIMENTO OU IDENTIFICADOR DE FRAGMENTAÇÃO [ NÃO USAREI ] 
		CRC8		    ; CÓDIGO DE CHECAGEM DE REDUNDÂNCIA CÍCLICA
	ENDC
	
;	CBLOCK	0x50
;		MBYTE_0
;		ANDRESS_MASTER
;		ANDRESS_SUBSISTEMA
;		DADO_MASTER
;	;NOVAS VARIÁVEIS
;
;	ENDC
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA
#DEFINE	FLAG_COL_START_BIT  BARRAMENTO, 3   ; BIT REFERENTE A COLISAO NO START_BIT
#DEFINE	FLAG_COL_ENVIAR_BIT BARRAMENTO, 4   ; BIT REFERENTE A COLISAO AO ENVIAR BIT
#DEFINE	FLAG_COLISAO	    BARRAMENTO, 1   ; BIT REFERENTE A COLISAO
#DEFINE	FLAG_BYTE_0	    ESTAGIO, 1	    ; FLAG REFERENTE AO ESTAGIO DO BYTE_0
#DEFINE	FLAG_ENDERECO	    ESTAGIO, 2	    ; FLAG REFERENTE AO ESTAGIO DO ENDERECO
#DEFINE	FLAG_DADO	    ESTAGIO, 3	    ; FLAG REFERENTE AO ESTAGIO DO DADO

#DEFINE FAROL		    ESTADO_SINALIZACAO, 0
#DEFINE RE		    ESTADO_SINALIZACAO, 1
#DEFINE FREIO		    ESTADO_SINALIZACAO, 2
#DEFINE SETA_ESQUERDA	    ESTADO_SINALIZACAO, 3
#DEFINE SETA_DIREITA	    ESTADO_SINALIZACAO, 4
#DEFINE REQUISICAO	    DADO_SINALIZACAO, 5
	
#DEFINE OP_COLISAO	    OPERACIONAL, 2	    
#DEFINE OP_SENSORES	    OPERACIONAL, 3	
#DEFINE OP_DIRECAO	    OPERACIONAL, 4	
#DEFINE OP_TRACAO	    OPERACIONAL, 5	
#DEFINE OP_SINALIZACAO	    OPERACIONAL, 6	
	
#DEFINE SENSOR_1	    PORTB, RB4
#DEFINE SENSOR_2	    PORTB, RB5
#DEFINE SENSOR_3	    PORTB, RB6
#DEFINE SENSOR_4	    PORTB, RB7
#DEFINE PWM_FREIO	    .2		    ;	PWM DO FREIO DESACIONADO
#DEFINE	I2C_ERRO	    BARRAMENTO_I2C, 0
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;A PARTIR DO ENDEREÇO ZERO DA EEPROM, DADOS EM ORDEM ALEATÓRIA
	ORG 0x2100
	DE	0X03,0X02,0X05,0X40	; VALORES FIXOS DO SUBSISTEMA
	   ;	BYTE END1 END2 DADO
	   ; END1 = DIREÇÃO
	   ; END2 = SINALIZAÇÃO
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA


;********************************************************************************************* 

;ROTINA DE TRATAMENTO DAS INTERRUPÇOES
	ORG 	0X04
;********************************************************************************************* 
; SALVAR E TAL
SALVA_REGS
	BANK0
	BSF	PORTA, RA1
	;CALL	        DELAY10MS
	MOVWF	W_TEMP
	SWAPF	STATUS, W
	MOVWF	STATUS_TEMP
	MOVF	PCLATH, W
	MOVWF	PCLATH_TEMP
	;MOVF	FSR, W
	;MOVWF	FSR_TEMP
;********************************************************************************************* 

;********************************************************************************************* 
    ; TRATAR O EVENTO
    BTFSS	PIR1, SSPIF
    GOTO	RESGATA_REGS
    BCF		PIR1, SSPIF
    CALL	TRATA_EVENTO
    XORLW	.0
    BTFSS	STATUS, Z
    GOTO	RESGATA_REGS
    BSF		I2C_ERRO
    GOTO	RESGATA_REGS

;********************************************************************************************* 

TRATA_EVENTO
	BANK1
	MOVF	SSPSTAT, W
	ANDLW	B'00101101'		; MASCARA DE BITS
	BANK0
	MOVWF	TEMP
	MOVLW	B'00001001'
	XORWF	TEMP, W
	BTFSS	STATUS, Z
	GOTO	IDENTIF_ESTADO2	

	; DISPOSITIVO ESCRAVO RESPONDE A OCORRENCIA DO ESTADO 1
TRATA_ESTADO1
	MOVF		SSPBUF, W		; REGISTRADOR É LIDO 
	MOVLW		0x70			; ENDEREÇO DOS DADOS DO L3
	MOVWF		FSR
	
	MOVLW		.12
	MOVWF		CONT_BYTES_I2C
	RETLW		.2

;********************************************************************************************* 

IDENTIF_ESTADO2
	MOVLW		B'00101001'
	XORWF		TEMP, W
	BTFSS		STATUS, Z
	GOTO		IDENTIF_ESTADO3
TRATA_ESTADO2
	MOVF		SSPBUF, W
	;MOVWF		DADO_I2C
	BSF		BARRAMENTO, 7
	MOVWF		INDF
	INCF		FSR
	DECFSZ		CONT_BYTES_I2C	    ; TESTA SE JÁ FOI ENVIADO TODOS OS 13 DADOS DO I2C L3
	    GOTO	$+2		    ; SO PARA PULAR CASO NÃO SEJA ZERO
	    ;BSF		CONT_BYTES_I2C, 7   ; SE ZERAR, SETA QUE TEM DADO NOVO
	    CALL	TRATA_L3
	RETLW		.2

;********************************************************************************************* 
IDENTIF_ESTADO3 ; ENVIA DADO DO I2C, O PRIMEIRO BYTE

	MOVLW		B'00001100'
	XORWF		TEMP, W
	BTFSS		STATUS, Z		; OCORREU ESTADO 3?
	GOTO	  	IDENTIF_ESTADO4

TRATA_ESTADO3
	BANK1
	BTFSC		SSPSTAT, BF			; TRANSMISSÃO EM ANDAMENTO?
	GOTO		TRATA_ESTADO3
	BANK0

ESCREVE_I2C
	BCF		SSPCON, WCOL		; APAGA A FLAG INDICADOR DE ESCRITA
	;MOVF		DADO_I2C, W	
	MOVLW		0X70;0X50
	MOVWF		FSR
	MOVF		INDF, W
	MOVWF		SSPBUF			; CARREGA O DADO A SER TRANSMITIDO
	BTFSC		SSPCON, WCOL		; OCORREU UMA ESCRITA NAO PERMITID
	GOTO		ESCREVE_I2C			; SIM, TRANSMITE NOVAMENTE
	BSF		SSPCON, CKP			; NAO, LIBERA A LINHA SCL
	RETLW		.2
;********************************************************************************************* 
IDENTIF_ESTADO4
	MOVLW		B'00101100'
	XORWF		TEMP, W
	BTFSS		STATUS, Z
	GOTO		IDENTIF_ESTADO5

TRATA_ESTADO4
	BANK1
	BTFSC		SSPSTAT, BF
	GOTO		TRATA_ESTADO4
	BANK0

ESCREVE_I2C_02
	BCF		SSPCON, WCOL
	INCF		FSR
	;MOVF		DADO_I2C, W
	MOVF		INDF, W
	MOVWF		SSPBUF
	BTFSC		SSPCON, WCOL
	GOTO		ESCREVE_I2C_02
	BSF		SSPCON, CKP
	RETLW		.2

;********************************************************************************************* 


IDENTIF_ESTADO5

    MOVLW		B'00101000'
    XORWF		TEMP, W
    BTFSC		STATUS, Z
    GOTO		TRATA_ESTADO5
    RETLW		.0

TRATA_ESTADO5
	    MOVLW	.1
	    CLRF	FSR
	    BSF		BARRAMENTO, 7	; HOUVE UMA LEITURA DO I2C
	    RETURN

;*********************************************************************************************

RESGATA_REGS
	
	BTFSC		INTCON, INTF	    ; TESTA SE O FLAG DA INTERRUPÇÃO DO RB0 TA HABILITADA
	    GOTO    TRATA_BARRAMENTO
	SWAPF		STATUS_TEMP, W
	MOVWF		STATUS
	SWAPF		W_TEMP, F
	SWAPF		W_TEMP, W
	MOVF		PCLATH_TEMP, W
	MOVWF		PCLATH
	;BCF	PORTA, RA1
	;MOVF		FSR_TEMP, W
	;MOVWF		FSR
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES
TRATA_BARRAMENTO
	BCF		SSPCON, CKP			; NAO, LIBERA A LINHA SCL
	MOVF	FSR, W
	MOVWF	FSR_TEMP
    BTFSC	FLAG_COLISAO
	GOTO	TRATAR_COLISAO
	GOTO	INICIO_START_SYNC

TRATAR_COLISAO
	BTFSS	    FLAG_COL_START_BIT
	    GOTO    LER_BITS
	    GOTO    INIC_CONT_START_SYNC
	    
INIC_CONT_START_SYNC
	INCF	CONTADOR_START_SYNC
	MOVLW	.155				;[ ]	DEIXA ESSE POR ULTIMO TO DO
	MOVWF	TMR0
	GOTO	START_SYNC
; INTERRUPÇÕES
INICIO_START_SYNC
	MOVLW	.8
	MOVWF	CONTADOR_BITS		; TEM QUE TER ISSO PARA QUE O CONTADOR DE BITS COMECE COM SE NAO ELE FICA PRESO NO LER BITS
	MOVLW	.111;.99;.30;.55		    ; SERÁ VISTO QUANTAS VEZES O TIMER0 ESTOURARÁ [X]
	MOVWF	TMR0
START_SYNC
	BTFSC	PORTB, RB0;GP2
	GOTO	VERIFICA_SLAVER	    ; QUANDO O GP2 DESCER, É TESTADO SE É SLAVE OU MASTER 
	BTFSC	INTCON, TMR0IF	    ; VERIFICA SE HOUVE ESTOURO DO TIMER 0
	GOTO	INCREMENTA_LIMPA    ; INCREMENTA O CONTADOR DO START_SYNC
	GOTO	START_SYNC	    ; SE NÃO, REINICIA
	
INCREMENTA_LIMPA
	BTFSC	CONTADOR_START_SYNC, 2	; VERIFICA E PASSOU DE 3 O INCREMTETO, SE SIM, SAI
	    GOTO	SAI_INT
	INCF	CONTADOR_START_SYNC
	BCF	INTCON, TMR0IF
	GOTO	INICIO_START_SYNC
	
VERIFICA_SLAVER
	MOVLW	0x60			; ENDEREÇO APONTADO CASO SEJA SLAVE NA MEMORIA
	MOVWF	FSR			; PONTEIRO APONTANDO NO ENDEREÇO 0x30 NA MEMÓRIA RAM
	MOVLW	.3			; CONTADOR DE BYTES, REFERENTE AO BYTE 0, MELHORAR ESSE DADO
	MOVWF	CONTADOR_BYTES
	DECFSZ	CONTADOR_START_SYNC	; DECREMENTA O CONTADOR E VERIFICA SE ELE É ZERO,
	GOTO	VERIFICA_MASTER		; SE FOR ZERO, O TIMER ZERO ESTOUROU 1 VEZ SÓ, ENTÃO É SLAVE
	;BSF	PROPRIETARIO, 0		; BIT 0 REFERENTE AO SLAVER
	BCF	PROPRIETARIO, 0		; LIMPA QUE NÃO É MASTER
	;BSF	GPIO,GP0	
	GOTO	START_BIT_INICIO	; INICIA A VERIFICAÇÃO DO START BIT
	
VERIFICA_MASTER				; VERIFICA SE É MASTER
	DECFSZ	CONTADOR_START_SYNC
	GOTO	SAI_INT			; DEU PROBLEMA, NÃO É UM START_SYNC
	;BCF	PROPRIETARIO, 0		; LIMPA QUE NÃO É SLAVE
	BSF	PROPRIETARIO, 0		; BIT 1 REFERENTE AO MASTER
	;BSF	PORTA, RA6
	;BSF	GPIO,GP0
	;MOVLW	0x40

	;MOVWF	FSR
	;MOVLW	.4
	;MOVWF	CONTADOR_BYTES
	GOTO	START_BIT_INICIO
;==================================================
START_BIT_INICIO

	;BSF	GPIO, GP1		; CASO O BARRAMENTO NÃO SUBA, ELE FOI TRATADO ANTERIORMENTE NO START_SYNC. SE O BARRAMENTO FICAR EM LOW, TODO O BARRAMENTO ESTARA COM PROBLEMAS
	BTFSS	PORTB, RB0;GP2		; ESPERA O BARRAMENTO SUBIR
	GOTO	START_BIT_INICIO	
START_BIT_CONFIGURA			; CONFIGURA O REINICIO DA CONTAGEM DO START BIT PARA O CONTADOR QUANDO O TIMER ZERO ESTOURAR
	BCF	INTCON, TMR0IF
	MOVLW	.174;.145			; O TMR0 ESTOURARÁ A CADA 130 US [X]
	MOVWF	TMR0
START_BIT
	BTFSS	PORTB, RB0;GP2
	GOTO	VERIFICA_START_BIT
	BTFSC	INTCON, TMR0IF		; VERIFICA SE O TIMER ZERO ESTOUROU
	GOTO	INCREMENTA_START_BIT	; SE SIM, INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT		; SE NÃO, CONTINUA A CONTAGEM
INCREMENTA_START_BIT
	 ;BSF	GPIO, GP4
	BTFSC	CONTADOR_START_BIT, 1	; TESTA SE HOUVE MAIS DE UM ESTOURO DO TIMER0, SE SIM, SAI DA INTERRUÇÃO
	    GOTO	SAI_INT
	INCF	CONTADOR_START_BIT	; INCREMENTA O CONTADOR DO START BIT
	GOTO	START_BIT_CONFIGURA 
VERIFICA_START_BIT

	DECFSZ	CONTADOR_START_BIT	; VERIFICA SE HOUVE APENAS UM ESTOURO NO TIMER 0 NA SUBIDA DO START BIT
	GOTO	SAI_INT			; SE HOUVE MAIS DE 1 OU MENOS, NÃO CARACTERIZA UM START BIT E SAI DA INTERRUPÇÃO
	GOTO	START_BIT_LOW_INICIO		; SE HOUVE APENAS 1 ESTOURO, CONTINUA A VERIFICAÇÃO PARA O TEMPO EM LOW

	
START_BIT_LOW_INICIO			; CODIGO PARECIDO COM A VERIFICAÇÃO DO TEMPO EM ALTA DO START BIT
	; BSF	GPIO, GP4
	BCF	INTCON, TMR0IF		; MAS AGORA É TESTADO COM O TEMPO EM LOW
	MOVLW	.186;.145		; [X]
	MOVWF	TMR0
START_BIT_LOW
	BTFSC	PORTB, RB0;GP2
	GOTO	SAI_INT			
	BTFSC	INTCON, TMR0IF
	GOTO	ESPERA_SUBIDA_START_BIT
	GOTO	START_BIT_LOW
	
ESPERA_SUBIDA_START_BIT
	BCF	INTCON, TMR0IF
	MOVLW	.225;.239;.225			; O TMR0 ESTOURARÁ A CADA 25 US [X]
	MOVWF	TMR0
ESPERA_SUBIDA_ST	
	BTFSC	PORTB, RB0;GP2
	GOTO	LER_BITS
	BTFSC	INTCON, TMR0IF
	GOTO	SAI_INT			; SE O BARRAMENTO NÃO SUBIR NO INTERVALO DE TEMPO DADO, NÃO CARACTERIZA UM START BIT
	GOTO	ESPERA_SUBIDA_ST
	
;====================================
	
LER_BITS
	;BSF	GPIO, GP2 ; APAGAR
	BCF	INTCON, TMR0IF		; LIMPA A FLAG DE ESTOURO DO TIMER ZERO
	MOVLW	.241;.232;.234		; O TIMER ZERO ESTOURARÁ A CADA 30 US (BASE), QUANDO HOUVER O ESTOURO, É VERIFICADO [X]
	MOVWF	TMR0			; O ESTADO DO BARRAMENTO, SE O BARRAMENTO ESTIVER EM ALTA, SIGNIFICA QUE O BARRAMENTO AINDA NÃO BAIXOU, OU SEJA, CARACTERIZA O BIT 1 (40(H)) > 30 US
	MOVLW   .220;.251;.248			; PASSA O VALOR PARA O MONITORA_BITS [X]
	MOVWF	MONITORA_BITS		; QUANDO CHEGAR EM 255 ESTOURA
LER_BITS_CONTINUA			; CASO O BARRAMENTO ESTEJA EM LOW, SIGNIFICA QUE O BARRAMENTO JÁ FOI PARA LOW, OU SEJA, O BIT LIDO É O ZERO (20(H) + 10(L)) = 30 US
	;BTFSS	GPIO, GP2
	;GOTO	VERIFICA_1_0
	;BTFSC	INTCON, TMR0IF		; VERIFICA SE HOUVE ESTOURO DO TIMER ZERO
	;GOTO	VERIFICA_1_0		; VERIFICA SE O BIT LIDO É ZERO OU UM
	INCFSZ	MONITORA_BITS		; INCREMENTA, SE ESTOURAR, É SINAL QUE HOUVE ALGUM ERRO, E O PROGRAMA SAI
	    GOTO    $+2			; SE NÃO ESTOURAR, CONTINUA
	    GOTO    SAI_INT		; SE ESTOURAR, SAI DA INTERRUPÇÃO
	
	BTFSC	PORTB, RB0;GP2
	    GOTO	LER_BITS_CONTINUA
	    GOTO	VERIFICA_1_0
	
	
	
;INCREMENTA_CONTADOR_BITS
;	INCF	CONTADOR_TEMPO_BITS
;	GOTO	LER_BITS
VERIFICA_1_0		    ; VERIFICA SE É O BIT 1 OU 0
	BTFSS	INTCON, TMR0IF    ;GPIO, GP2
	GOTO	BIT_0
	GOTO	BIT_1

BIT_0
	BCF	STATUS, C
	RLF	INDF
	
	
	
	DECFSZ	CONTADOR_BITS		; DECREMENTA O CONTADOR DE BITS 
	GOTO	ESPERA_BIT_0_MUDAR	; SE NÃO FOR ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	INCF	FSR			; SE ACABOU, INCREMENTA O PONTEIRO PARA O PROXIMO ENDEREÇO DE MEMÓRIA	    
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES		; DECREMENTA O CONTADOR DE BYTES QUE TEM QUE SER LIDO
	GOTO	ESPERA_BIT_0_MUDAR	; CASO NÃO SEJA ZERO, ESPERA O BIT ZERO TERMINAR NO BARRAMENTO PARA LEITURA DO PRÓXIMO
	GOTO	CONCLUIDA_LEITURA	; CASO SEJA ZERO, A LEITURA DOS DADOS DO BARRAMENTO ESTÁ FINALIZADO.
	
ESPERA_BIT_0_MUDAR		
	BTFSS	PORTB, RB0;GP2
	GOTO	ESPERA_BIT_0_MUDAR
	GOTO	LER_BITS

BIT_1
	BSF	STATUS, C
	RLF	INDF
	
	
	
	
	DECFSZ	CONTADOR_BITS
	GOTO	ESPERA_BIT_1_MUDAR
	INCF	FSR
	;BSF	GPIO, GP4
	
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
	MOVLW	.8
	MOVWF	CONTADOR_BITS
	
	DECFSZ	CONTADOR_BYTES
	GOTO	ESPERA_BIT_1_MUDAR
	GOTO	CONCLUIDA_LEITURA
	
ESPERA_BIT_1_MUDAR
	;BTFSC	GPIO, GP2
	;GOTO	ESPERA_BIT_1_MUDAR

	BTFSS	PORTB, RB0;GP2
	GOTO	$-1
	GOTO	LER_BITS
	
CONCLUIDA_LEITURA
	;TESTA SE É PARA O DE COLISÃO
	MOVLW	.2
	XORWF	ENDERECO, 0
	BTFSC	STATUS, Z
	    GOTO    SALVA_COLISAO
	    
	;TESTA SE É PARA O DE SENSORES
	MOVLW	.3
	XORWF	ENDERECO, 0
	BTFSC	STATUS, Z
	    GOTO    SALVA_SENSORES
	    
	;TESTA SE É PARA O DE DIREÇÃO
	MOVLW	.4
	XORWF	ENDERECO, 0
	BTFSC	STATUS, Z
	    GOTO    SALVA_DIRECAO
	 
	;TESTA SE É PARA O DE TRAÇÃO
	MOVLW	.5
	XORWF	ENDERECO, 0
	BTFSC	STATUS, Z
	    GOTO    SALVA_TRACAO
	
	;TESTA SE É PARA O DE SINALIZAÇÃO
	MOVLW	.6
	XORWF	ENDERECO, 0
	BTFSC	STATUS, Z
	    GOTO    SALVA_SINALIZACAO
	    
	GOTO	SAI_INT
	;BSF	BARRAMENTO, 6	; SINALIZA QUE A LEITURA FOI FINALIZADA
	;BTFSC	DADO, 7
	;    GOTO    COLISAO	; SE HOUVER COLISÃO, TEM QUE LIGAR ALERTA, FREIO E PARAR
	;BTFSS	PROPRIETARIO, 0 ; É MASTER?
	;    GOTO    SAI_INT
	    ;GOTO    PASSA_DADO_SINALIZACAO
	;+BSF	PORTA, RA6
	; TESTA SE O VALOR NO DADO É MENOR DO QUE 15 [ X01XXXXX ] -> ILUMINAÇÃO 
	;MOVLW	B'01100000'	; PASSA A MASCARA PARA O WORK PARA FAZER O AND
	;ANDWF	DADO, 0		; FAÇO O AND COM O DADO, PARA PEGAR SOMENTE OS BITS 5 E 6 E SALVAR NO WORK O RESULTADO
	;XORLW	B'00100000'	; FAÇO OUTRO XOR COM O WORK PARA CHECAR SE SOMENTE O BIT 5 É 1, CASO SEJA, O RESULTADO É ZERO
	;BTFSS	DADO, 6		; TESTA SE O BIT 6 ESTA EM 1
	;    GOTO    TESTA_SENSORES	; SE NÃO DEU, O VALOR NÃO INTERESSA AO SUBSISTEMA DE SINALIZAÇÃO
	;    GOTO    PASSA_DADO_SINALIZACAO

SALVA_COLISAO
	MOVF	DADO, W
	MOVWF	COLISAO
	GOTO	SAI_INT
SALVA_SENSORES
	MOVF	DADO, W
	MOVWF	SENSORES
	GOTO	SAI_INT
SALVA_DIRECAO
	MOVF	DADO, W
	MOVWF	DIRECAO
	GOTO	SAI_INT
SALVA_TRACAO
	MOVF	DADO, W
	MOVWF	TRACAO
	GOTO	SAI_INT
SALVA_SINALIZACAO
	MOVF	DADO, W
	MOVWF	SINALIZACAO
	GOTO	SAI_INT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	BSF		SSPCON, CKP			;LIBERA A LINHA SCL
	CLRF	CONTADOR_START_SYNC
	CLRF	CONTADOR_START_BIT
	BCF	INTCON, INTF		; LIMPA QUE HOUVE INTERRUPÇÃO DO RB0
	BCF	BARRAMENTO, 1
	BCF	FLAG_COLISAO
	BCF	FLAG_COL_START_BIT
	BCF	BARRAMENTO, 6		; LIMPA A FLAG
	BSF	BARRAMENTO, 5
	MOVF		FSR_TEMP, W
	MOVWF		FSR
	SWAPF		STATUS_TEMP, W
	MOVWF		STATUS
	SWAPF		W_TEMP, F
	SWAPF		W_TEMP, W
	;MOVF		PCLATH_TEMP, W
	;MOVWF		PCLATH
	;BCF	BARRAMENTO, 4
	;BCF	BARRAMENTO, 2
	;CLRF	BARRAMENTO
	;BCF	GPIO, GP4
;	BANK1
;	BSF	TRISB, 0	; COLOCA O RB0 COMO ENTRADA (ALTA IMPEDANCIA)
;	BANK0
	
	;SWAPF	STATUS_TEMP,W
	;MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	;SWAPF	W_TEMP,F
	;SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.

	
LE_EEPROM
;LER DADO DA EEPROM, CUJO ENDEREÇO É INDICADO EM W
;DADO LIDO RETORNA EM W
	ANDLW	.127		;LIMITA ENDEREÇO MAX. 127
	BANK1				;ACESSO VIA BANK 1
	MOVWF	EEADR		;INDICA O END. DE LEITURA
	BSF		EECON1,RD	;INICIA O PROCESSO DE LEITURA
	MOVF	EEDATA,W	;COLOCA DADO LIDO EM W
	BANK0				;POSICIONA PARA BANK 0
	RETURN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
	
INICIO
	;********************************************************************************************* 
; CONFIGURAR COMO ESCRAVO O MSSP
	BANK1
	MOVLW		B'00011000'		
	IORWF		TRISC, F	; CONFIGURA PINOS SDA E SCL COMO ENTRADA
	BANK0
	MOVLW		B'00110110'	; SLAVE MODE, 7 BIT ENDEREÇO
	;MOVLW		B'00111110'	; SLAVE MODE, 7 BIT ENDEREÇO, COM INTERRUPÇÃO NO START E STOP BIT
	MOVWF		SSPCON		; CONFIGURA COMO ESCRAVO O DISPOSITIVO
					; HABILITA A PORTA SERIAL E CONFIGURA PINOS COMO SDA E SCL <5> 
					; ATIVA MODO ESCRAVO COM 7 BITS DE ENDERECO <3:0>
	BANK1
	CLRF		SSPSTAT		; LIMPA REG SSPSTAT
	BSF		SSPSTAT, SMP	; CONTROLE DE SLOW RATE DESABILITADO 
					; NIVEIS DE ENTRADA CONFORME ESPECIFICADO 
	BCF		SSPCON2, SEN	; CLOCK STRETCHING ATIVADO SOMENTE NA TRANSMISSAO <0>

	MOVLW		0x1E	; W RECEBE ENDEREÇO 
	MOVWF		SSPADD		; ENDEREÇO NO REGISTRADOR SSPADD
	BSF		PIE1, SSPIE	; LLIGA CHAVE INDIVIDUAL DE INTERRUPÇAO DO MÓDULO MSSP

	BSF		INTCON, PEIE	; INTERRUPÇÃO DE PERIFERICOS ATIVADA
	BSF		INTCON, GIE	; LIGA CHAVE GERAL DE INTERRUPÇÃO
	;BANK0

	;BANK1			;ALTERA PARA O BANCO 1
	MOVLW	B'11110001' 	;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISB		;COMO SAÍDAS
	MOVLW	B'00100000'
	MOVWF	TRISA		; INICIALIZA PORTA
	MOVLW	B'10000010'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW	B'11010000'
	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	;CALL	3FFH
	;MOVWF	OSCCAL
	MOVLW	.100
	MOVWF	PR2		; PERIODO DO PWM
	BANK0			;RETORNA PARA O BANCO
	MOVLW	B'00001100'
	MOVWF	CCP1CON
	MOVLW	PWM_FREIO      
	MOVWF	CCPR1L		; DUTY CICLE
	MOVLW	B'00000100'	; HABILITA O TIMER2
	MOVWF	T2CON		; HABILITA O TIMER2
	MOVLW	'D'
	MOVWF	DADO
	MOVLW	'E'
	MOVWF	ENDERECO
	MOVLW	'B' 
	MOVWF	BYTE_0

	MOVLW	B'00110001'
	MOVWF	T1CON		; HABILITANDO O TIMER 1 - 1:8	
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
;	MOVLW	'I'
;	MOVWF	DADO_I2C
;	MOVLW	'L'
;	MOVWF	LUCAS1
;	MOVLW	'U'
;	MOVWF	LUCAS2
;	MOVLW	'C'
;	MOVWF	LUCAS3
;	MOVLW	'A'
;	MOVWF	LUCAS4
;	MOVLW	'S'
;	MOVWF	LUCAS5
;	MOVLW	' '
;	MOVWF	LUCAS6
	BSF	PORTB, RB1
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

; * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

; RB0 -> LER O BARRAMENTO E ESCREVE
;
; RB1 -> FAROL
; RB2 -> RÉ
; RB3 -> PWM -> FREIO
; RB4 -> SE
; RB5 -> SD
;

MAIN
	;BTFSC	BARRAMENTO, 7
	;    GOTO    ENVIA
;	CALL	VERIFICA_BARRAMENTO
;	GOTO	ENVIA_DADOS
	
	
	
	
;	CALL DELAY10MS
;	CALL DELAY10MS
;	CALL DELAY100MS
;	CALL DELAY100MS
;	CALL DELAY100MS
;	CALL DELAY100MS
    BTFSC	MONITORA_SUBSISTEMAS, 0
	GOTO	ENVIA_DIRECAO
	
	
	CALL DELAY10MS
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 0
	MOVLW	.16	    ; CODIGO DE REQUISIÇÃO DOS SENSORES
	GOTO	ENVIA
;======================================================================================
ENVIA_DIRECAO
	BTFSC	MONITORA_SUBSISTEMAS, 1
	    GOTO	ENVIA_TRACAO
	CALL DELAY10MS
	
	
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 1
	MOVLW	.7	    ; CODIGO DE REQUISIÇÃO DA DIREÇÃO
	GOTO	ENVIA
;======================================================================================
ENVIA_TRACAO	 
	BTFSC	MONITORA_SUBSISTEMAS, 2
	    GOTO	ENVIA_SENSORES
	CALL DELAY10MS
	
	
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 2
	MOVLW	.13	    ; CODIGO DE REQUISIÇÃO DA TRAÇÃO
	GOTO	ENVIA
;======================================================================================
ENVIA_SENSORES	
	BTFSC	MONITORA_SUBSISTEMAS, 3
	    GOTO	ENVIA_DIRECAO_2
	CALL DELAY10MS
	
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 3
	MOVLW	.16	    ; CODIGO DE REQUISIÇÃO DOS SENSORES
	GOTO	ENVIA
;======================================================================================
ENVIA_DIRECAO_2	 
	BTFSC	MONITORA_SUBSISTEMAS, 4
	    GOTO	ENVIA_TRACAO_2
	CALL DELAY10MS
	
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 4
	MOVLW	.7	    ; CODIGO DE REQUISIÇÃO DA DIREÇÃO
	GOTO	ENVIA
;======================================================================================
ENVIA_TRACAO_2    
	BTFSC	MONITORA_SUBSISTEMAS, 5
	    GOTO	ENVIA_SINALIZACAO
	
	CALL DELAY10MS
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 5
	MOVLW	.13	    ; CODIGO DE REQUISIÇÃO DA TRAÇÃO
	GOTO	ENVIA
;======================================================================================
ENVIA_SINALIZACAO
	BTFSC	MONITORA_SUBSISTEMAS, 6
	    GOTO	LIMPA_MONITORIA
	
	CALL DELAY10MS    

	
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	BSF	 MONITORA_SUBSISTEMAS, 6
	MOVLW	.96	    ; CODIGO DE REQUISIÇÃO DA SINALIZAÇÃO
	GOTO	ENVIA
LIMPA_MONITORIA
	    CLRF    MONITORA_SUBSISTEMAS
	    
;   TODO
    ; PEDE REQUISICAO DOS SENSORES (OBS*) [ TESTA SE FAZ TEMPO QUE ENVIOU, AI PEDE CASO TENHA DEMORADO ] 
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA DIREÇÃO
    ;MOVLW  REQUISIÇÃO DA DIREÇÃO
    ;GOTO    ENVIA
    
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA TRAÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DOS SENSORES (OBS*)
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA DIREÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA TRAÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA SINALIZAÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
	
    ; OBS* TALVEZ NÃO PRECISE DA REQUISIÇÃO DOS SENSORES, POIS ELES IRÃO ENVIAR A CADA MUDANÇA DE ESTADO
    ; TALVEZ PRECISE PARA SABER SE ESTA FUNCIONANDO?
    
    ; REINICIA O CIRCULO DE REQUISIÇÕES, SO É INTERROMPIDO CASO HAJA UM DADO DO I2C
	
	
	
	BTFSC	    CONT_BYTES_I2C, 7		; VERIFICA SE FOI ENVIADO UM PACOTE DO L3
	    CALL    TRATA_L3
	    ;GOTO    ENVIA
	
	BSF	    PORTA, 2
;	BANK1
;	BTFSC	    SSPSTAT, P	    ; TESTA SE HOUVE UM STOP BIT
;	    GOTO    ENVIA
;	BANK0
	GOTO	MAIN
	;GOTO	MAIN
ENVIA
	
	;CALL	DELAY10MS
	MOVWF	W_AUX
	BCF	CONT_BYTES_I2C, 7
	BANK0
	CALL	VERIFICA_BARRAMENTO
	MOVF	W_AUX, W
	GOTO	ENVIA_DADOS
	GOTO MAIN
	
;#########################################################################################
FIM_ENVIA_DADOS
;	BANK1
;	BCF	SSPSTAT, P	; LIMPA A FLAG DO STOP BIT
;	BANK0
	;BCF	BARRAMENTO, 7
	BSF		SSPCON, CKP			;LIBERA A LINHA SCL
	MOVF	FSR_TEMP, W 
	MOVWF	FSR
	BCF	INTCON, INTF
	BSF	INTCON, GIE
	BTFSC	BARRAMENTO, 0
	    GOTO    ENVIA
	GOTO	MAIN
;=============================================================
VERIFICA_BARRAMENTO		; VERIFICO SE O BARRAMENTO ESTÁ LIVRE POR 200 US
	;BSF	PORTA, RA7
	BSF	INTCON, GIE	; HABILITO A INTERRUPÇÃO
	BCF	BARRAMENTO, 5	; LIMPA O SINALIZADOR DE LEITURA DO BARRAMENTO
	; TESTA SE O VALOR LIDO É REFERENTE AO STOP DA COLISAO
	;   SE FOR, TRATAR ESSE DADO
	BCF	INTCON, T0IF
	MOVLW	.208;.40;.20
	MOVWF	TMR0
	BTFSS	PORTB, RB0		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	
VERIFICA_BARRAMENTO_0
	BTFSS	PORTB, RB0		; VERIFICA SE O BARRAMENTO ESTÁ EM LOW
	 GOTO	VERIFICA_BARRAMENTO
	BTFSS	INTCON, T0IF
	GOTO	VERIFICA_BARRAMENTO_0
	;BSF	BARRAMENTO, 0	   ; SINALIZO BARRAMENTO LIVRE. (É NECESSÁRIO?)
	BTFSC	BARRAMENTO, 5	; HOUVE UMA LEITURA NO BARRAMENTO?
	 GOTO	VERIFICA_BARRAMENTO
	;BCF	PORTA, RA7
	RETURN
;=============================================================
ENVIA_DADOS
	      BCF	SSPCON, CKP			; NAO, LIBERA A LINHA SCL
;		BTFSC	PORTA, RA7
;		    GOTO    FIM_ENVIA_DADOS
	      BCF	INTCON, GIE		; DESABILITA AS INTERRUPÇÕES
;	      BCF	INTCON,	PEIE
	;=========================================
	      MOVWF	DADO_1	    ; O QUE TIVER NO WORK VAI SER O DADO A SER ENVIADO
				    ; O DADO CONTERÁ A REQUISIÇÃO PARA CADA UM DOS SUBSISTEMAS
	;=========================================
	      MOVF	FSR, W
	      MOVWF	FSR_TEMP
;	      BCF	INTCON,	INTE
;	      BCF	INTCON, RBIE
	      

	CLRF	ESTAGIO
	;CLRF	INTCON		    ;	DESABILITA A INTERRUPÇÃO
	;MOVLW	0X00
	MOVLW	0X03
	MOVWF	BYTE_0_1
	MOVLW	0X00
	MOVWF	ENDERECO_1
	BANK1
	MOVF	SSPADD, W
	BANK0
	;MOVWF	DADO_1
	
	
	
	;MOVF	ENDERECO_SINALIZACAO, W  ;	MOVO O ENDEREÇO DO SUBSISTEMA QUE ENVIARÁ DOS DADOS
	;MOVWF	ENDERECO	    ;	PARA O ENDEREÇO QUE SERÁ LIDO
	;MOVF	ESTADO_SINALIZACAO, W
	;MOVWF	DADO
	;GOTO	ENVIAR_OK

	
ENVIAR_OK
	    BSF		BARRAMENTO, 0
	    MOVLW	0x5F			; ENDEREÇO APONTADO PARA O ENREREÇO RESERVADO PARA LEITURA DOS DADOS 
						; PARA SER INCREMENTADO POR IGUAL NO ENVIO DOS BYTES
	    MOVWF	FSR			; PONTEIRO
	    MOVLW	.3
	    MOVWF	CONTADOR_BYTES
	    
	    BTFSS	PORTB, RB0		; TESTE
	       GOTO	MAIN
	    
	    CALL	START_SYNC_MASTER	; PASSA 250 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	    GOTO	START_BIT_ENVIA
FIM_START_BIT
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
		MOVLW	.8
		MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 1	    ; SINALIZA QUE É O ENVIO DO BYTE 0
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_BYTE_0
		MOVLW	.16			; DELAY EM US
		CALL	DELAY_MICRO
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
	;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
		MOVLW	.8
		MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 2	    ; SINALIZA QUE É O ENVIO DO ENDEREÇO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_ENDERECO
		MOVLW	.16			; DELAY EM US
		CALL	DELAY_MICRO
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		INCF	FSR		    ; VALOR INCREMENTADO DO PONTEIRO, PARA QUE EM TODOS OS TEMPOS SEJAM IGUAIS
			;BSF	CONTADOR_BITS, 3	; COLOCO O VALOR 8 NO CONTADOR DE BITS QUE ANTES ESTAVA ZERADO
		MOVLW	.8
		MOVWF	CONTADOR_BITS
		BSF	ESTAGIO, 3	    ; SINALIZA QUE É O ENVIO DO DADO
		GOTO	ENVIA_BYTE	    ; O VALOR QUE ESTIVER NO WORK, SERÁ ENVIADO
FIM_DADO
		MOVLW	.16			; DELAY EM US
		CALL	DELAY_MICRO
		RLF	INDF		    ; ULTIMO ROTATE PARA QUE PEGAR O VALOR QUE ESTAVA NO CARRY E DEIXAR ORIGINAL
		DECF    CONTADOR_BYTES	    ; DECREMENTA O CONTADOR DE BYTES TODA VEZ QUE É ENVIADO UM BYTE
		CALL	DELAY_US
		BSF	PORTB, RB1	    ; COLOCA O BARRAMENTO EM ALTA
		
		; TODO
		; SE O DADO ENVIADO FOR PARA RECALL, FAZ UM GOTO PARA O FIM_ENDERECO MANDANDO O VALOR DO ULTIMO BYTE, O DADO PARA O SUBSISTEMA.
		
		BCF		BARRAMENTO, 0

;		BTFSC	BARRAMENTO, 7	    ; OS DADOS ENVIADOS ERAM DOS SENSORES?
;		    GOTO    ENVIOU_SENSORES ; TRATA
;		BTFSC	REQUISICAO
;		    GOTO    REQUISICAO_ENVIADA
		GOTO	FIM_ENVIA_DADOS
;REQUISICAO_ENVIADA
;		;BCF	REQUISICAO	    ; QUANDO HOUVER UMA REQUISIÇÃO, ENVIA UMA UNICA VEZ O DADO
;		MOVF	ESTADO_SINALIZACAO, W
;		MOVWF	DADO_SINALIZACAO
;		GOTO	FIM_ENVIA_DADOS
;ENVIOU_SENSORES
;		BCF	BARRAMENTO, 7
;		GOTO	FIM_ENVIA_DADOS	    ; CASO TAMBÉM TENHA TIDO UMA REQUISIÇÃO, O BIT DE REQUISIÇÃO NÃO FOI LIMPO
;					    ; LOGO, O DADO SERÁ REENVIADO.
	
START_BIT_ENVIA
	;DELAY DE 50 US EM ALTA
	BSF	PORTB, RB1
	MOVLW	.50
	CALL DELAY_MICRO
	BSF	PORTB, RB1
	BTFSS	PORTB, RB0;GP2
	    GOTO    COLISAO_START_BIT	; SE HOUVER COLISÃO, TRATAR OS DADOS REFENTE A ELA
	MOVLW	.100
	CALL DELAY_MICRO

	; DELAY DE 150 US EM BAIXA, NÃO NECESSITA VERIFICAR COLISÃO
	BCF	PORTB, RB1
	MOVLW	.150
	CALL	DELAY_MICRO
	
	GOTO	FIM_START_BIT
	

ENVIA_BYTE 
    BTFSS   INDF, 7
	GOTO	ENVIA_0
	GOTO	ENVIA_1

ENVIA_0

	BSF	PORTB, RB1
	;CALL	DELAY_US
	MOVLW	.19		    ; DELAY DE 19 US
	CALL	DELAY_MICRO
	RLF	INDF	    
	
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    PORTB, RB1		; FICA EM BAIXA O BARRAMENTO
;	BANK1
;	BCF	TRISB, 0    ; SAIDA, BARRAMENTO EM BAIXA
;	BANK0
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0

ENVIA_1
	BSF	PORTB, RB1
	RLF	INDF	
	; PASSA 30 US EM ALTA
;	BTFSS	PORTB, RB0;GP2		; TESTA SE O BARRAMENTO NÃO ESTÁ COM COLISÃO
;	    GOTO    FIM_ENVIA_DADOS	; TRATAR COLISAO BITS
	    
	MOVLW	.3			; DELAY EM US
	CALL	DELAY_MICRO
	BSF	PORTB, RB1
	BTFSS	PORTB, RB0;GP2
	    GOTO    FIM_ENVIA_DADOS	; SE HOUVER COLISÃO NESSE PONTO, É ERRO, NÃO DEVERIA TER, TRATAR OS DADOS REFENTE A ELA
	MOVLW	.26			; DELAY EM US
	CALL	DELAY_MICRO
	BTFSS	PORTB, RB0;GP2
	    GOTO    COLISAO_ENVIAR_BITS	; SE HOUVER COLISÃO, TRATAR OS DADOS REFENTE A ELA
	    
	MOVLW	.6			; DELAY EM US
	CALL	DELAY_MICRO
	
	DECFSZ	CONTADOR_BITS
	    GOTO    TEMPO_EM_BAIXA      ; VAI PASSAR 20 US EM BAIXA
	    BCF	    PORTB, RB1		; FICA EM BAIXA O BARRAMENTO
	    BTFSC   ESTAGIO, 3		; VERIFICA SE TERMINOU DE ENVIAR O DADO
		GOTO	FIM_DADO
	    BTFSC   ESTAGIO, 2		; VERIFICA SE TERMINOU DE ENVIAR O ENDERECO
		GOTO	FIM_ENDERECO
		GOTO	FIM_BYTE_0	; CASO NÃO ESTEJA NENHUM, O BYTE ENVIADO É BYTE_0
;==============================
TEMPO_EM_BAIXA
;	BANK1
;	BCF	TRISB, 0    ; SAIDA, BARRAMENTO EM BAIXA
;	BANK0
	BCF	PORTB, RB1
	; PASSA 20 US EM BAIXA
	;CALL	DELAY_US
	
	MOVLW	.20			; DELAY EM US
	CALL	DELAY_MICRO
	
	GOTO	ENVIA_BYTE
;===============================
COLISAO_START_BIT
	
	BSF	FLAG_COL_START_BIT		; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT
	BSF	FLAG_COLISAO		; SINALIZO QUE HOUVE UMA COLISÃO
	
	;MOVLW	B'11011000'
	BSF 	INTCON, GIE				;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
	
COLISAO_ENVIAR_BITS								
	BCF	INDF,	7				; SETO O BIT DO REGISTRADOR APONTADO PARA 0, POIS HOUVE COLISAO 
	;BCF	PORTB, RB1
	DECFSZ	CONTADOR_BITS, F			; TEM QUE DECREMENTAR O CONTADOR DE BITS, POIS ELE FOI LIDO JÁ E SERA LIDO OUTRA VEZ CASO NÃO DECREMENTE
	    GOTO	$+2
	    GOTO	MAIN
	BSF	FLAG_COL_ENVIAR_BIT			; SINALIZO QUE HOUVE UMA COLISÃO NO START BIT NO REGISTRADOR BARRAMENTO
	BSF	FLAG_COLISAO				; SINALIZO QUE HOUVE UMA COLISÃO
	;MOVLW	B'11011000'
	BSF 	INTCON, GIE					;   ATIVAR AS INTERRUPÇÕES
	BSF	INTCON,	INTF				; SINALIZO A INTERRUPÇÃO PARA QUE SEJA TRATADA IMEDIATAMENTE
	GOTO	MAIN
;====================================
START_SYNC_MASTER			; START SYNC DE 500 US [MASTER]
	BCF	PORTB, RB1		;2493 cycles
	MOVLW	0xF2
	MOVWF	d1
	MOVLW	0x02
	MOVWF	d2
START_SYNC_MASTER_0
	DECFSZ	d1, f
	GOTO	$+2
	DECFSZ	d2, f
	GOTO	START_SYNC_MASTER_0

			;3 cycles
	;GOTO	$+1
	;nop
	BSF	PORTB, RB1

			;4 cycles (including call)
	RETURN
;START_SYNC_SLAVE
;;	BANK1
;;	BCF	TRISB, 0    ; SAIDA
;;	BANK0
;	BCF	PORTB, RB1
;	; PASSA 250 US EM BAIXA
;			;244 cycles
;	MOVLW	.82
;	MOVWF	DELAY_SYNC
;START_SYNC_SLAVE_0
;	DECFSZ	DELAY_SYNC, F
;	GOTO	START_SYNC_SLAVE_0
;	
;	;GOTO	$+1
;	BSF	PORTB, RB1
;;	BANK1
;;	BSF	TRISB, 0 ; ENTRADA, BARRAMENTO VAI PRA 1
;;	BANK0
;	RETURN

DELAY_US
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    
    RETURN
DELAY100MS
			;99993 cycles
	MOVLW	.30
	MOVWF	CONT_1
	MOVLW	.79
	MOVWF	CONT_2
DELAY100MS_0
	DECFSZ	CONT_1
	GOTO	$+2
	DECFSZ	CONT_2
	GOTO	DELAY100MS_0
			;3 cycles
	GOTO	$+1
	NOP
			;4 cycles (including call)
	RETURN
	
;#########################################################################################
DELAY10MS
			;49993 cycles
	MOVLW	0x0E
	MOVWF	d1
	MOVLW	0x28
	MOVWF	d2
DELAY10MS_0
	DECFSZ	d1, f
	GOTO	$+2
	DECFSZ	d2, f
	GOTO	DELAY10MS_0

			;3 cycles
	GOTO	$+1
	NOP

			;4 cycles (including call)
	RETURN
DELAY_MICRO
    MOVWF   TEMPO0		    ; CARREGA EM TEMPO_1 ATE AONDE VAI ESPERAR
    NOP
    NOP
    DECFSZ  TEMPO0,F		; SE PASSOU O TEMPO?
    GOTO    $-3 			; NÃO, VOLTA
    RETURN
    
    
;   TODO
    ; PEDE REQUISICAO DOS SENSORES (OBS*) [ TESTA SE FAZ TEMPO QUE ENVIOU, AI PEDE CASO TENHA DEMORADO ] 
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA DIREÇÃO
    ;MOVLW  REQUISIÇÃO DA DIREÇÃO
    ;GOTO    ENVIA
    
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA TRAÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DOS SENSORES (OBS*)
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA DIREÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA TRAÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
    ; PEDE REQUISIÇÃO DA SINALIZAÇÃO
	; ESPERA POR X MS A RESPOSTA E SALVA NO SEU BYTE CORRESPONDENTE 
	
    ; OBS* TALVEZ NÃO PRECISE DA REQUISIÇÃO DOS SENSORES, POIS ELES IRÃO ENVIAR A CADA MUDANÇA DE ESTADO
    ; TALVEZ PRECISE PARA SABER SE ESTA FUNCIONANDO?
    
    ; REINICIA O CIRCULO DE REQUISIÇÕES, SO É INTERROMPIDO CASO HAJA UM DADO DO I2C
    
    ; QUANDO HOUVER UM DADO DO I2C, PODE SER OS SEGUINTES
	;CÓDIGO
	
	; 83 - SSP - MOTORISTA PEDE O ESTADO DOS SUBSISTEMAS
	    ; 0 | 0XFF | 0XFF | 0XFF | 0XFF | 0XFF
	    
	; 80 - RSP - CARRO RESPONDE O ESTADO DOS SUBSISTEMAS
	    ; 0 | TRAÇÃO | DIREÇÃO | SINALIZAÇÃO | SENSORES | COLISAO
	    
	; 81 - ASP - MOTORISTA ESCREVE PARA O CARRO OS NOVOS COMANDOS PARA OS SUBSISTEMAS
	    ; 0 | TRAÇÃO | DIREÇÃO | SINALIZAÇÃO | 0XFF | 0XFF	
	    
	; 6  - ACK - CARRO CONFIRMA A INSTRUÇÃO RECEBIDA
	    ; INSTRUÇÃO | 0XFF | 0XFF | 0XFF | 0XFF | 0XFF
	    
	; 5  - ENQ - MOTORISTA PERGUNTA SE OS SUBSISTEMAS ESTÃO OPERACIONAIS
	    ; DISPOSITIVO | 0XFF | 0XFF | 0XFF | 0XFF | 0XFF
	    
	; 21 - NAK - CARRO INFORMA ERRO NO CÓDIGO RECEBIDO
	      ; COD_ERRO | CÓDIGO DA INSTRUÇÃO | 0XFF | 0XFF | 0XFF | 0XFF
	  
	; 51 - E1B - MOTORISTA COLOCA O CARRO PARA RECAL, TENDO COMO MUDAR PARAMETROS DOS SUBSISTEMAS
	      ; ENDEREÇO DA EEPRON | DADO PARA COLOCAR NO ENDEREÇO | 0XFF | 0XFF | 0XFF | 0XFF 
	      
	; CODIGO DE ERRO
	; 1 - CRC   - ERRO DE CRC-8
	; 2 - IDC   - INSTRUÇÃO DESCONHECIDA OU INEXISTENTE
	; 3 - DNO   - DISPOSITIVO NÃO OPERACIONAL
	; 4 - DIN   - DISPOSITIVO INEXISTENTE
	; 5 - MDC   - MESTRE NÃO RECONHECIDO
	; 6 - OVF   - OVERFLOW - ERRO DE OPERAÇÃO DE CÁLCULO

TRATA_L3
	; TRAVA O CLOCK TALVEZ E NO FIM LIBERA [ DO I2C ]
	
	;TRATA O CRC-8 PARA VER SE TA TUDO OK, CASO NÃO ESTEJA ENVIA UM NAK COM O ERRO DE CRC
	
	MOVLW	.83	    ; SSP
	XORWF	COD, 0
	BTFSC	STATUS, Z
	      GOTO    MOTORISTA_SOLICITA_SUBSISTEMAS
	
	MOVLW	.81	    ; ASP
	XORWF	COD, 0
	BTFSC	STATUS, Z
	      GOTO    MOTORISTA_COMANDO_SUBSISTEMAS
	   
	MOVLW	.5	    ; ENQ
	XORWF	COD, 0
	BTFSC	STATUS, Z
	      GOTO    ESTA_OPERACIONAL
	      
	MOVLW	.51	    ; E1B
	XORWF	COD, 0
	BTFSC	STATUS, Z
	      GOTO    RECALL
	
	MOVLW	.2	    ; INSTRUÇÃO DESCONHECIDA
    	GOTO	ENVIA_NAK   ; ENVIA O NAK
	
MOTORISTA_SOLICITA_SUBSISTEMAS
	; O ENDEREÇO DO CARRO VAI SER O ENDEREÇO NÚMERO 15
	; RESPONTE COM O 80 RSP
	; 0 | TRAÇÃO | DIREÇÃO | SINALIZAÇÃO | SENSORES | COLISAO
	
	; NÃO PRECISA ENVIAR ACK AQUI
;	MOVLW   .83
;	CALL	ACK
	
	MOVLW	0X01
	MOVWF	SOH
	
	MOVLW	0X0F	; ENDEREÇO DO SLAVE VAI SER 15
	MOVWF	IDS
	
	MOVLW	.10
	MOVWF	IDD	; ENDEREÇO DO MASTER VAI SER 10
	
	MOVLW   .80
	MOVWF	COD
	
	MOVLW	.0
	MOVWF	DATA_P1
	
	MOVF	TRACAO, W
	MOVWF	DATA_P2

	MOVF	DIRECAO, W
	MOVWF	DATA_P3
	
	MOVF	SINALIZACAO, W
	MOVWF	DATA_P4
	
	MOVF	SENSORES, W
	MOVWF	DATA_P5
	
	MOVF	COLISAO, W
	MOVWF	DATA_P6

	MOVLW	.255
	MOVWF	PAD
	
	;TRATA O CRC-8 COM OS DADOS PRESENTES E CALCULA O VALOR DO CRC
	MOVLW	.255
	MOVWF	CRC8
	
	RETURN
	
MOTORISTA_COMANDO_SUBSISTEMAS
	; 81 - ASP - MOTORISTA ESCREVE PARA O CARRO OS NOVOS COMANDOS PARA OS SUBSISTEMAS
	; 0 | TRAÇÃO | DIREÇÃO | SINALIZAÇÃO | 0XFF | 0XFF	
	
	MOVF	DATA_P2, W
	MOVWF	TRACAO
	
	MOVF	DATA_P3, W
	MOVWF	DIRECAO
	
	MOVF	DATA_P4
	MOVWF	SINALIZACAO
	
	; OS OUTROS SÃO SENSORES, NÃO PODE MUDAR O ESTADO DELES
	
	RETURN
	
ESTA_OPERACIONAL
	; 5  - ENQ - MOTORISTA PERGUNTA SE OS SUBSISTEMAS ESTÃO OPERACIONAIS
	; DISPOSITIVO | 0XFF | 0XFF | 0XFF | 0XFF | 0XFF
	CLRF	DATA_P1
	MOVLW	.255
	MOVWF	DATA_P2
	MOVWF	DATA_P3
	MOVWF	DATA_P4
	MOVWF	DATA_P5
	MOVWF	DATA_P6
	
	MOVLW	.2			; VERIFICA O ENDEREÇO DOS SUBSISTEMAS
	XORWF	DATA_P1, 0
	BTFSC	STATUS, Z
	    GOTO    COLISAO_OPERACIONAL
	
	MOVLW	.3
	XORWF	DATA_P1, 0
	BTFSC	STATUS, Z
	    GOTO    SENSORES_OPERACIONAL
	
	MOVLW	.4
	XORWF	DATA_P1, 0
	BTFSC	STATUS, Z
	    GOTO    DIRECAO_OPERACIONAL
	    
	MOVLW	.5
	XORWF	DATA_P1, 0
	BTFSC	STATUS, Z
	    GOTO    TRACAO_OPERACIONAL
	    
	MOVLW	.6
	XORWF	DATA_P1, 0
	BTFSC	STATUS, Z
	    GOTO    SINALIZACAO_OPERACIONAL    
	    
	    
COLISAO_OPERACIONAL
	    BTFSS   OP_COLISAO	; OPERACIONAL, 1
		RETURN
	    MOVLW   .2
	    MOVWF   DATA_P1
	    RETURN
SENSORES_OPERACIONAL
	    BTFSS   OP_SENSORES	; OPERACIONAL, 2
		RETURN
	    MOVLW   .3
	    MOVWF   DATA_P1    
	    RETURN
DIRECAO_OPERACIONAL
	    BTFSS   OP_DIRECAO	; OPERACIONAL, 3
		RETURN
	    MOVLW   .4
	    MOVWF   DATA_P1
	    RETURN
TRACAO_OPERACIONAL
	    BTFSS   OP_TRACAO	; OPERACIONAL, 4
		RETURN
	    MOVLW   .5
	    MOVWF   DATA_P1
	    RETURN
SINALIZACAO_OPERACIONAL
	    BTFSS   OP_SINALIZACAO	; OPERACIONAL, 5
		RETURN
	    MOVLW   .5
	    MOVWF   DATA_P1
	    RETURN
	
; 21 - NAK - CARRO INFORMA ERRO NO CÓDIGO RECEBIDO
	      ; COD_ERRO | CÓDIGO DA INSTRUÇÃO | 0XFF | 0XFF | 0XFF | 0XFF
ENVIA_NAK
	    
	    MOVWF   DATA_P1	; RECEBE DO WORK O CODIGO DE ERRO QUE SERÁ ENVIADO.
	    	    
	    MOVF    COD, W
	    MOVWF   DATA_P2
	    
	    MOVLW   .15	    ; MEU ENDEREÇO
	    MOVWF   IDS
	    
	    MOVLW   .10
	    MOVWF   IDD	    ; ENDEREÇO DE DESTINO
	    
	    MOVLW   .21
	    MOVWF   COD
	    
	    MOVLW   .255
	    MOVWF   DATA_P3
	    MOVWF   DATA_P4
	    MOVWF   DATA_P5
	    MOVWF   DATA_P6
	    
	    RETURN
	    
	    
RECALL	
	    ; TODO
	    ; VAI PREPARAR OS 4 BYTES DE DADOS PARA ENVIAR NO BARRAENTO DCH [ OWP ]
	    ; BYTE_0 COM O VALOR 4
	    ; ENDEREÇO DO SUBSISTEMA QUE SERÁ ALTERADO
	    ; ENDEREÇO DE MEMORIA DA EEPROM QUE SERÁ ALTERADO
	    ; VALOR QUE SERÁ COLOCADO NA EEPROM DO SUBSISTEMA
	    ; SETO UMA FLAG QUE SERÁ A FLAG SINALIZANDO O RECALL
	    ; GOTO ENVIA
	    
	    ; 0 | TRAÇÃO | DIREÇÃO | SINALIZAÇÃO | SENSORES | COLISAO
	
    
    END
    
    
;	SOH		    ; INICIO DO PACOTE
;	IDS		    ; IDENTIFICADOR DE ORIGEM
;	IDD		    ; IDENTIFICADOR DE DESTINO
;	COD		    ; CÓDIGO DE INSTRUÇÃO
;	DATA_P1		    ; INFORMAÇAO
;	DATA_P2		    ; INFORMAÇAO
;	DATA_P3		    ; INFORMAÇAO
;	DATA_P4		    ; INFORMAÇAO
;	DATA_P5		    ; INFORMAÇAO
;	DATA_P6		    ; INFORMAÇAO
;	PAD		    ; ENCHIMENTO OU IDENTIFICADOR DE FRAGMENTAÇÃO [ NÃO USAREI ] 
;	CRC8		    ; CÓDIGO DE CHECAGEM DE REDUNDÂNCIA CÍCLICA
    
    
;	TRACAO
;	DIRECAO
;	SINALIZACAO
;	SENSORES
;	COLISAO